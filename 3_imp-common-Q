       Note : if your joining the company then first take one pen and paper and draw the exection flow of each module in that paper
              So next time you can understand the flow easily   

 Wirte Code important Questions 
 -------------------------------
     1) Explain Dead Lock with example 
     2) Expalin wait() , notify() with exapmle 
     3) Explain Singleton class with example 
     4) Expalin Immutable class with example
     5) Exaplin OOPs principle in 1 example
     6) Explain Volatile keyword with example
     7) Explian Throws using example
     8) Expalin this , this() , this(args)  and super , super() , super(args) with example
     9) Write code to perform Unit testing for private methods , fields , constructor
     10) Private members cannot access outside the class , I can access explain with example
     11) Explain Method refrence with Example
     12) Explain Parallel stream 
    
     
    1) Explain Dead Lock with example 
    +++++++++++++++++++++++++++++++++
    public class Demo {
        public static void main(String[] args) throws InterruptedException {
            String s1 = "resource1";
            String s2 = "resource2";

            Thread t1 = new Thread() {
                public void run() {
                    synchronized (s1) {
                        System.out.println("Resource 1 Locked by thread");

                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        synchronized (s2) {
                            System.out.println("Resource 2 is call");
                        }
                    }
                }
            };

            Thread t2 = new Thread() {
                public void run() {
                    synchronized (s2) {
                        System.out.println("Resource 2 Locked by thread");
                        try {
                            Thread.sleep(1000);
                        } catch (InterruptedException e) {
                            // TODO Auto-generated catch block
                            e.printStackTrace();
                        }
                        synchronized (s1) {
                            System.out.println("Resource 1 is call");
                        }
                    }

                }
            };

            t1.start();
            // Thread.sleep(1000);
            t2.start();
        }
    }
    
     2) Expalin wait() , notify() with exapmle 
     ++++++++++++++++++++++++++++++++++++++++++
            public class Demo {
            
            int amount = 10000;
            public synchronized void withdraw(int amount) {
                System.out.println("withdraw method call");
                if(this.amount < amount) {
                    System.out.println("amount is less");
                    try {
                        System.out.println("Calling deposit method");
                        wait();
                    } catch (InterruptedException e) {
                        // TODO Auto-generated catch block
                        e.printStackTrace();
                    }
                }
                System.out.println("Again in withdraw method");
                this.amount= this.amount - amount;
                System.out.println("withdraw method  amount is : "+ this.amount);
            }
            public synchronized void deposit(int amount) {
                System.out.println("deposit method call and amount is : "+ this.amount);
                this.amount= this.amount + amount;
                notify();
            }
            public static void main(String[] args) throws InterruptedException {
                Demo d  = new Demo();
                Thread t1 = new Thread() {
                    public void run() {
                        d.withdraw(15000);
                    }
                };
                t1.start();
                
                Thread.sleep(1000);
                
                Thread t2 = new Thread() {
                    public void run() {
                        d.deposit(10000);
                    }
                };
                t2.start();
            }
        }

     1) What is Immutable class in java How to create the Immutable class in java( Ex Wrapper classes)
     +++++++++++++++++++++++++++++++++++++++++++++
     -> First of Immutable class means the state of the object cannot be change and that class cannot be inherited
     -> TO create the immutable class 
          1) class declared as final
          2) variables as private 
          3) through Constructor only values are initialize 
          4) and through getters only value can get
          5) Not use setters in this Immutable class , so we cannot set the values from outsider class
     -> Ex: 
            final class Student {
               private int id;
               private String name;

               public Student(int id , String name){
                  this.id = id;
                  this.name=name;
               }

               public int getId(){ return id};
               public String getName(){return name};
            }

            class Main{
              public static void main(String[] args){
                Student s = new Student(1 , "Niles");
                sysout(id + s.getId());
                sysout(name + s.getName());
              }
            }
     -> But in case there is the List Object to store in the List data ex: private List<String> hobbies
     -> To add the data into hobbies we need to create another list object like = List<String> hobbyList = new ArrayList<>();
     -> Now here both hobbies and hobbyList instances are pointing towards same List object 
     -> what ever the data we add in hobbiList that is automatically change in hobbies 
     -> So to avoid this 
     -> In constructor we need to create the seperate list instate for hobbies and for hobbyList we have seperate list instance
          public Student(int id , String name , List hobbyList){
          this.id=id;
          this.name=name;
          this.hobbies= new ArrayList<>(){
             for(String hobby : hobbyList){    // here all hobbyList data is copy into actual hobby refrence
                hobbies.add(hobby);
              }
           } 
     -> Through getters we can get and change the state of the instance like we have Student class having hobbies we can change the instance like this
        List<String> list = s.getHobbies();   and then  list .add("new hobby" )
     -> Solution  for getters : retrun newList through getters not actual List 
           public List getHobbies(){
              List newList = new ArrayList<>(){
               for (String hobby : hobbies){
                 newList.add(hobby);
               }
               return newList;
              }
           } 
    POJO class code 
    ---------------
             final class Student {
             private int id;
             private String name;
             private List<String> hobbies

             public Student(int id , String name , List hobbies){
             this.id = id;
             this.name= name;
             ----}
             public int getId(){return id;}
             public String getName(){retrun name;}
             --
             public void setId(int id ){this.id = id};
             public void setName(String name){this.name= name};
             ---
           }
     Final Code
     ----------
          public final class Student{
           private int id;
           private String name;
           private List<String> hobbies;

           public Studnet(int id, String name , List hobbyList){
             this.id = id;
             this.name=name;
             this.hobbies= new ArrayList<>();
             for(String hobby : hobbyList){
               hobbies.add(hobby);
             }
           }
           public int getId(){return id};
           public String getName(){return name;}

           public List getHobbies(){
           List newList = new ArrayList<>();
           for(String hobby : hobbies){
               newList.add(hobby);
           }
              return newList;
           }
         }

     -> Why Instance variables are make as final in Immutable class
       -----------------------------------------------------------
       -> There is no requirement as such to make the variable final.
       -> But for others developers , or ourselfs mistakes , for this intent only we make it as final to show it is immutable
       -> Immutable class properties we never need to change in future , so it is better to make it final.


     
       
  58)Write a class which show all OOPS principles ??
  +++++++++++++++++++++++++++++++++++++++++++++++
   interface User {                          // Abstraction
       User getUserById(Integer id);
   }

   public class UserImpl implements User {  // Inheritence
       private String userName;             // Encapsulation

      //setter                              
      //getter

       @Override
       public User getUserById(Integer id) { // Polymorphism
           // Implementation logic 
       }

       public static void main(String[] args) {
           UserImpl userImpl = new UserImpl();
           userImpl.setUserName("JaneDoe");
           System.out.println("User Name: " + userImpl.getUserName());
           User fetchedUser = userImpl.getUserById(2);
           System.out.println("Fetched User Name: " + ((UserImpl) fetchedUser).getUserName());
       }
   }

2) How to create the Singleton class in Java and How it willbe work on MultiThreading enviorment 
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
 -> 1st of all how to create object in java objRef obj = new constructor() , Employee e1 = new Employee
 -> Here employee e1 is created into Heap memeory , e2 also and e2 creatred into head memeory , if 2 assiment e2=e1 then point same object in heap memory
 -> Now this we know  , Then what is Sinleton class
 -> Class which has only 1 instance created into heap memory and there is no another way to create another instance for that class, then that class is singleton
 -> POINT 1 ) we know that we use constructor to create object 
            - Then how to avoid to crate object using constructor 
            - declare constructor as private , so new keyword we cannot create object
 -> POINT 2 ) How to create object for that class if we avoid to create object using constructor 
            - Create 1 static method ehich return the actual object of the class , so we can retrun the object 
            - Why static method to return the object : before creating the object we can use static method only so 
              ------------------------------------------------------------------------------------------------------
 -> POINT 3) There are 2 important types to create Singleton class 
             1) Eager loading
             2) Lazy loading ( explain in Interview)
 -> Eager Loading for Singleton class
    --------------------------------- 
       Steps 1: Create private Constructor
       Steps 2: Create static method and return the object of the class
       Steps 3: Declare class object as private and static
                Why private static
                ------------------
                if we create object only then it will create into Heao memory 
                If we give refrence as static then this object store into metaspace
       => Now when we call the object then it is going to be return the same instance , and this is what we want to do
    code-
    ------------------------------------------------------------
       public class Employee{
         private static Employee singletonObj = new Employee();
         private Employee(){};
         public static Employee instance(){
           return singletonObj;
         }
       }
    ------------------------------------------------------------
       => Note: But interviewer is not looking for this because simple and problem is even though we dont required still also that object is created into the Heap 
          when class loader loads the class  and after that we store it into the metaspace
       => Solution is Lazy Loading
 -> Lazy Loading for Singleton class
    --------------------------------
      Step 1: Every this is same only difference is 
            - Object we creating for the sinfleton class is same as private static and additionaly we add Volatile and it is initially initialize as null 1st
            - Why Volatile:
      Step 2: Through static method through which we are returing object - int hat method we check 1st Singleton object is null or not
              If null then new object and return Singleton object
      code: 
      ---------------------------------------------------------
        public class Employee{
         private static  volatile Employee singletonObj = null;
         private Employee(){};
         public static Employee instance(){
           if( singletonObj == null){
             sinletonObj = new Emoloyee();
           }
           return singletonObj;
         }
       }
      ----------------------------------------------------------
       => Note: But here problem in this code creates multiple object in multithreading - Then how to overcome this problem
                In multithreading 2 threads , it will create  2 object , this is not that we are reqirening for singleton class
       => Solution : Synchronized keyword
 -> Synchronize
    ------------------------------------------
       only change :
       if(singletonObj == null){
          synchronized(Employee.class){
              singletonObj = new Employee();
          }
       }
    -------------------------------------------
      Note: Here 2 threads are there 1st thread is unlock and object create in heap then 2nd Thread is lock , next time 2nd thread unlock
            But here is alsp 1 problem that 1st thread create object into heap which is not destroy by 2 thread and 2nd thread also create object 
      Solution: Double checked Locking pattern 
-> Double checked Locking pattern
   -------------------------------
     -> Check thread is null before and after the sunchronized keyword
   code:
   -----------------------------------------------------------------
      if(singletonObj == null){
         synchronized(Employee.class){
            if(singletonObj == null){
              singletonObj = new Employee();
            }
         }
         return singletonObj;
      }
     Note: Upto tell interviewer
           THis double locked also breeak by reflection 
     Solution: ENum singleton - Which is not break by reflection


  -
    55) How to write the Junit test cases to the private methods
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         -> When we declare the method as private , then as per the Access Modifier rules we cannot access those methods outside the class 
         -> But for Unit testing we test the individual methods working properly or not 
         -> To write the test cases for private methods we have 2 ways
              1st one is 
              -----------
             1) Calling private methods from the public method and write the Junit test cases for the public method and cover all use cases of private method 
                (But here problem is if the method contains complex logic then through public method all private uses cases are not cover to test ) , so this cause defect after later testing
              2nd one is 
              -----------
             2) Reflection

          Ex : 
          -------
            public class Library{

                private int sumOfTwoNumbers(Integer a , Integer b){
                return a+b;
                }

                public int sumOfNumbers(int a , int b){
                return a+b;
                }
            }

            1st how to write test cases for public methos   -> run as Junit
            ------------------------------------------------
            public class LibraryTest{
               @Test
               public void testSumOfNumbers(){
                    Library library = new Library();
                    int sum =  library.sumOfNumbers(10,30);
                    assertsEqual(40 , sum);
               }
            }
             2nd How to write test case for private using calling private method by public method
             --------------------------------------------------------------------------------------
             -> create a public method in Library class 
             -> through public method retrun private the method

             -> public class Library{

                private int sumOfTwoNumbers(Integer a , Integer b){
                return a+b;
                }

                public int sumOfNumbers(int a , int b){
                return sumOfTwoNumbers(a,b);
                 }
                }
             -> Testing same as public method

              3rd case using Reflection to write the test cases for private methods
              ---------------------------------------------------------------------
              Rule 1 -> 1st get the method through reflection
              Rule 2 ->  2nd change the access modifier -> using setAccessible().
              Rule 3 -> Invoke the object with the parameters
              Rule 4 -> Assert the value to check the it correct or not 
                public class LibraryTest{
                     @Test
                     public void testSumOfTwoNumbers(){
                        Class libClass =  Class.forName("com.google.Library");    // to load the class
                        Method method =  libClass.getDeclaredMethods();           // to get the methods
                        method.setAccessibile(true);  
                        Object libObj = libClass.newInstance();                            // to change methods from class
                        int sum =  method.invoke( libObj , 10 , 30);
                        assertsEqual(40 , sum)

                        or

                         Method method = Library.class.getDeclareMethod("sumOfTwoNumbers",Integer.class , Integer.class);
                         method.setAccessibile(true);
                         Library library = new Library();
                         int sum =  method.invoke(library , 10,30);
                         assertsEqual(40 , sum);

                     }
                  }   

8) Explain Volatile and Synchronize keyword in java with example 
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  -> To understand this 2 keywords , 1st of all we need to understand the computer architecture 
  -> computer architecture have heve 1) Hard Dist 2) Ram 3) Processor(CPU)(cache memory + processor)
  -> Like Java program is available into hardDisk , when we run that program then JVM allocate some memory into RAM , and with the help of RAM and processor 
     the program is going to execute 
  -> Now CPU can have multiple processor like OctaCOre Processor (means paralley 8 threads are going to execute simultaneously)
  -> And each processor has its own cache memory | cache memory is used to increase the performance
  -> Suppose Core 1 wants to read some values form RAM , then RAM Sends the value through cahce memory to processor and program is execute , 
  -> Next time thread 1 does not reads values form RAM , it takes directly from cache memory to execute the program
  -> EX : 
         -> We have employee class 
         -> class Employee{
             private String name;
             private int salary;
            }
         -> Now I want to perform some operations like -> Bonous +500 , tax -1000
         -> Now for simplicity this program is executed by 2 threads paralley
         -> Thread T1 picks core 1 to perform bonous operation salary 10000 + bonous 500 = 10500 salary and save into its cache memory and also update into RAM
         -> Thread T2 picks core 2 to perform tax operation    salary 10000 + tax -1000  = 9000 salary and save into its cache memory and also override it into RAM
         -> But the final salary we want 10000 + 500 + 1000 = 9500  , so this is the Issue
  -> To solve this issue we Have Volatile keyword in java
  -> Volatile keyword : 
         -> When we decalre the variable as volatile then , processor is directly read the values from RAM , not from cache memeory
         -> Caching mechanism is bypass here
  -> Sunchronize keyword :
         -> Synchronize keyword is used to execute the threads sequencially in multithreading enviorment 
         -> Example: employee class with updateSalary method
             class Employee{
                private String name;
                private volatile int salary;

                public void updateSalary(int s , String type){
                  if(type=="INCREAMENT"){
                    this.salary =this.salary+s;                            this is Critical doe
                  }else{
                    this.salary = this.salary-s;
                  }
                }
             }
         -> If this critical code is picks by 2 threads simultaneously then this condition is called RARE Condition
         -> Thread T1 increament bonous +500 => salary = 10500
         -> Thread T2 decrement tax -1000    => salary = 9000
         -> THis values are vice versa override into RAM 
         -> But here problem is both the values are wrong , because actual salary is = 9500
         -> So to solve this issue Critical code we always want to execute sequentially 
         -> So to avoid this Rare conditon java provide Synchronized keyword
         -> public synchronized void updateSalary(int s , String type){
                  if(type=="INCREAMENT"){
                    this.salary =this.salary+s;                            this is Critical doe
                  }else{
                    this.salary = this.salary-s;
                  }
                }
  -> Note: When method or block is Synchronized then by default its variables are volatile
     -------------------------------------------------------------------------------------


    Explain Method refrence in java (:: refrence operator)
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   -> In Java 1.8 it introduce , a method reference is a shorthand technique to call a method directly using the ::(refrence) operator. 
   -> Method refrence only refer the existing methods either static or instance or constructors without explicitly calling them.
   -> We use method references when we have a functional interface with a single abstract method i.e (SAM interface) and 
      whose method signature matches the method we are referencing.
   -> Commonly we use Method refrence in Stream operations, functional interfaces like Supplier, Consumer, Predicate, and Function.
   -> The common Benefits of Method References are 1) Improved Readability 2) Reusability 3) Avoid Boilerplate Code
   -> EX:  Static method refrence s 
           @FunctionalInterface
            interface Operation{
              public int calc(int a , int b);
            }
           -----------------------------------------
            class Calc{
              public static int add(int a , int b){
              return a+b;
              }

              public static int sub(int a , int b){
              return a-b;
              }
            }
            -----------------------------------------
            class Main{
              public static void main(String[] args){
                  Operation obj = Calc::add; // Calc::sub  // without paranthesis
                  sysout(obj.Calc(10.20));
              }
            }
    -> EX : Instance method refrence 
           @FunctionalInterface
            interface Operation{
              public int calc(int a , int b);
            }
           -----------------------------------------
            class Calc{
              public int add(int a , int b){
              return a+b;
              }

              public int sub(int a , int b){
              return a-b;
              }
            }
            -----------------------------------------
            class Main{
              public static void main(String[] args){
                  Calc cobj = new Calc();
                  Operation obj = cobj::add; // Calc::sub  // without paranthesis
                  sysout(obj.Calc(10.20));
              }
            }


    65) Expalin the difference between super, super() , super(args ) in java
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     1) super :refers to superclass members (variables or methods).
               Used to avoid ambiguity when the subclass and superclass have members with the same name.
               Explicit usage is required if a member in the subclass shadows the superclass's member.
     2) super() calls the superclass's default constructor. explicitly specified required
     3) super(args) calls the superclass's parameterized constructor. explicitly specified required
        -> super                                     super keyword with method
            =====
            class A{
              int x =10'                               show( super class method)
            }
            class B extends A{
              int x=20;                                show( instance emthod)

              void print(){
               int x = 30;                              show();
               sysout(x);    // 30                      this.show();
               sysout(this.x); // 20                    super.show();
               sysout(super.x); //10
              }
              public static void main(String[] args ){

                B obj = new B();
                obj.print();
              }
            }   output: 

            super() and super(param)  // note child with default or param constructor both have super() default
            ========================
         class Main {
             public static void main(String[] args) {
              new B();
                 
             }
         }

         class A{
             A(){
                this(10);
                 System.out.println("A class Constructor");
             }
             A(int a){
                 System.out.println("A class Paran Constructor"+ a);
             }
         }
         class B extends A{
             B(){
                 this(20);
                System.out.println("B class Constructor"); 
             }
             B(int b){
                 System.out.println("B class Param Constructor"+b);
             }
         }

         A class Paran Constructor10
         A class Constructor
         B class Param Constructor20
         B class Constructor

  66) Expalin the difference between this ,this() , this(args)
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         this  :  this keyword refer the current class object always and it is implicitly present into instance method, constructor , initialization block
                 note : explicitly required when instance variable and local variable name are same
         this() :  call the default constructor of current class  and implicitly present
         this( arg1 , arg2 ..)  : call parameterized constructor of current class we need to add explicitly as 1st statement  in default cons

           class Demo{                                                class Demo{
              
                Demp(){                                                Demo(){
                Sysout("default cons")                                 this(5);
                }                                                       Sysout("default cons");
                                                                        }
                Demo(int x){                                            Demo(int x){
                this();                                                 sysout(" param cons" x);
                Sysout("parameter cons x");                             }
                }

               public static void main(String[] args ){                 public static void main(String[] args ){
               new Demo(5);                                              new Demo();
             }                                                            }
           }                                                             }
           output -> default cons                                      output -> param cons 5 
                     param Cons 5                                                 default cons

         Explain this keyword with example
             ---------------------------------
             class Demo{

              int x = 10;
              void show(){         // note if this method is static then this code gives error why because of this not refer
              sysout(x);          //here implicitly this.x
              }
             public static void main(String[] args ){
                  Demo d = new Demo();
                  d.show();
                }
             }

             explanation : here int x is an instancr variable and d is refrence variable 
                           d scope is within the method only but it gives output as 10 why
                           because x is implicitly this.x so 

        Expalin this code 
         -------------------
         class Demo{

         Demo(int x){};
         public static void main(String[] args ){
             new Demo();
           }
         }
        // error why  :- because of default constructor not present so 

       
       Explain Junit Testing  ( for Controller , Service , Repository and REST API's)
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        => Testing individual components of the application is called as Unit testing.
        => Unit testing is used to identify weather code is working as expected or not.
        => Unit testing is used to identify bugs in the code.
        => With the help of unit testing we can identify bugs at early stage (before giving to testing team).
        => By performing unit testing we can provide quality code (bug free code) to higher environments.
         Annotations
         -----------
        -> @ExtendWith(MockitoExtension.class) 
                    -> class level , This annotation automatically initialize the mock object into the test class with the help of @Mock and @InjectMock annotation
                    -> If we dont declare this annotation then we need to mannualy inject the mock object
        -> @Mock    -> To inject other class dependency ( mock dependency)
        -> @InjectMocks -> To inject same class dependency ( mock dependency)
        -> @BeforeEach  -> The method which is annotate with @BeforeEach , then that method is going to execute before the every Test method
                           The method is used to initialize the data or setup the datamto use for the test method
        
       -> JUNIT 4 test cases annotations
         -------------------------------
       -> @Test        -> method level annotation to test the individual method
       -> @BeforClass  -> If we execute the logic before the test cases then we create the method as static and annotate with @BeforeClass 
                          This static method execute before all the test cases
       -> @AfterClass  -> the method which annotate with @AfterClass then that method is used for cleapUP activites or close up activiteis 
                          THis method is execute at last after all the test cases
       -> @Before      -> the method which annotate with @Before then that method execute before the test case mehtod 
                          Before the test case method execute ,if I want to initilize some data then we use @Before
       -> @After       -> the method which annotate with @After  then that method is execute after the test case method
       -> @Test(timeout = 20000) if test case take more than 2 sec time then it automatic fail
       -> @Ignore     ->  TO ignore the test case (means not execute)

       -> JUnit 5 test cases annotation (note JUnit 5 has backward compatibility means it support Junit 3 and 4)
          -------------------------------
           JUnit 5 is the combination of 2 paltforms  1) JUnit platform 2) Junit Jupiter(provide new annotations) 3) JUnit Vintage
          -> to use JUNIT 5 add 2 dependicies 1) Junit Jupiter 2) Junit params
          -> @BeforeAll  -> Same as @BeforeClass 
          -> @AfterAll   -> Same as AfterClass
          -> @BeforeEach -> same as @Before
          -> @AfterEach  -> same as @After
          -> @Disable    -> to ignore the specific test case
          -> @Timeout

       ->  Mockito annotations
          --------------------
          -> @Mock
          -> @injectMock
          -> @ExtendWith(MockitoExtension.class)
          -> @MockBean
          -> @Captor
       -> Rest api testing ( testing for GET API , PUT Api , Delete APi , )
       ---------------------
          -> @SpringBootTest  - class level ( to start our application so we can test the runtime classes like Respository inteface)
          -> @LocalServerPort
          -> https://www.youtube.com/watch?v=Hh17JDpsKqc watch for full rest testing

       -> Methods available in Assertions class ( Assertions class is used to validate the result with actual result)
          1) assertEquals(actaul , result)   more method same (but overloaded)
          2) asserArraysEquals()   - for array to validate the result
          2) assertIterableEquals() - to check list data same or not
          4) assertAThrows()  



       Introduction
        ------------
         ->  Hi , My name is Nilesh , I am a B.Tech graduate , and currently I am working in Infogain India private limited as Java Developer
         ->  And Total I have 3.1 years of Experience as Java Developer and In this period of Time , I got the oppertunity to work with several java based technologies 
             like Java , J2EE, Spring , SPring Boot , REst Api's , Microservices , Oracle DataBase and Several
             tools like  Git , Maven , SonarQube , Junit etc
         -> Talking about my project , Currently I working on IES application 
            We are developing this application for Rhode Island Goverment 
            and with the help of this application we are providing health and insurance plans  for the RI state citizens 
            We are providing 
            -> SNAP 
             -> CCAP
             -> Medicaid
             -> Medicare
             -> QHP and
             -> RIW
           ANd if citizens wants to apply for this plan then they need to visit to the nearest DHS department , where the Caseworkers are working who are going to apply
           plan for the citizen because our app is interanet app
           Caseworker use this IES , they collect the data from the citizen and determine the citizen is eligible for the plan or not 
           For every plan, conditions will be available  , if citizens data matching with those condition , citizen will be approved for the plan 
          -Then  he will get the benifit amount of paln on monthly basis

           ANd talking about my role in this IES , I am working on Corraspondance module  , and through this module I am going to send the notices to the citizens email id
           if they successfully apply for the plan , and also if there plan is going  to expire we send those notices also 

           And I am also responsible to develop the rest api's by dividing the component classes into entity , services , controller , writing the test cases for the classes
           Handling the exception for the classes , sending api response , to client web

           ANd talking about my day to day activities 
             - daily I engage in the  activities like :
      ---------------------------------------------------------
         1) API Development: Designing, implementing, and deploying APIs for various functionalities.
         2) Test Case Writing: Creating and maintaining unit and integration test cases to ensure code quality.
         3) Code Reviews: Reviewing code using tools like SonarQube to ensure compliance with coding standards and best practices.
         4) Testing Support: Assisting during SIT and UAT phases. Addressing bugs reported in JIRA and providing bug-free code.
         5) Email Notifications: Sending notifications to citizens' email IDs using the respective modules.
         6) Git Operations: Performing Git operations for code updates and version control.
         7) JIRA Updates: Documenting and updating the progress of the tasks on JIRA.
         8) Scrum Meetings: Attending daily Scrum meetings to discuss progress, blockers, and plans.

         And talking about my current work in my project
       +++++++++++++++++++++++++++++++++++++++++++++++++++
       -> Currenty RI state goverment provides us the new Eligibility criteria for the new citiens who are going to apply for the new plans 
       -> according to that we are going to be updating the Eligibility determination module 
       
        


        1) What is Java and Why Java
        +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         -> What is Java 
          --------------
           -> Java is one highly secured , platform independent , roboust , Object oriented programming language 
           -> Wiht the help of java we can develop scalable , reuseable and effiecient applications like web , distributed , mobile applications
           -> Java has rich framework support like spring , spring boot , hibernate  , so application development is very fast
           -> Aslo java has rich libriry support like like :
           -> Also java has rich community support : 
           -> Also java support modern technologies like : 


         -> Now a days there are lot of programming languages like python , .net , c , c++ etc
         -> But with the help of java we can develop 1) platform independent 
                                                     2) highly secured
                                                     3) Scalable and efficient  applications 
         -> With the help of java we can develop the applications like 1) Web , 3) Distributed , 3) Mobile applications
         -> Java provides rich support of libraries like 1) File handling
                                                         2) Multithreading 
                                                         2) Data base 
                                                         3) Data structures 
                                                         4) networking etc 
         -> And also framework suppport like 1) Spring
                                             2) Spring boot  
                                             3) Hibernate
                                             4) Kafka etc 
         -> Java have rich community support because most widely used programming language
         -> And it support modern technologies like 1) Microservices 
                                                    2) CLoud Computing
                                                    3) AI/ML
                                                    4) Big data

        Java:
           - Java is one high-level, object-oriented programming language and with the help of this language we can develop
             the platform-independent applcations .
           - Programming language : means to write programs
           - Platform means       : Applications which are develop in java language they can run in any operating system , because of JVM 
           - Technology means     : we can develop web applications , distribution applications , standalone applications

        -> The main key features of java language are 
            1) Platform Independence :   "Write Once, Run Anywhere" (WORA) 
            2) Object-Oriented       : Focuses on objects and classes, making it modular and reusable.
            3) Robust and Secure     : Includes strong memory management, exception handling, and built-in security mechanisms.
            4) Multithreading        : Supports concurrent programming, making it suitable for modern, high-performance applications.
            5) Rich Ecosystem        : Vast libraries, frameworks (e.g., Spring, Hibernate), and tools simplify development.
            6) Garbage Collection    : Automatic memory management reduces the risk of memory leaks.

        -> Why Java 
            because we can develop 1) Web Applications
                                   2) Enterprise Applications
                                   3) Android Development    -> primary language for Android apps
                                   4) Microservices          -> Spring Cloud for building distributed systems.
            Pyhton - when machine learning , scripting
            c++    - when gaming and hardware interaction
         

       2)explain what are the S.O.L.I.D principles and Why should we use SOLID principles?
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       -> Every Software application is incomplete with out SOLID principles 
       -> Because they provide basic  fundamental guidelines to develop Object Oriented based software application . 
       -> With the help of this guidelines we can make the application code easily  understandable , scaleable , reuseable , maintainable , and testable 
       -> S.O.L.I.D principles are use to avoids the bad designing of the software.
       -> SOLID is an acronym of five principles, each principle has it's own guidelines like they have

       -> Single Responsibility Principle (SRP)
       -> Open-Closed Principle (OCP)
       -> Liskov Substitution Principle (LSP) 
       -> Interface Segregation Principle (ISP)
       -> Dependency Inversion Principle (DIP)

       -> Single Responsibility Principle
       ++++++++++++++++++++++++++++++++++
         - According to this principle every Java class must have only single functionality. 
         - Because if we Implementation of multiple functionalities in a single class then the code mashup 
         - and if any modification we want required to do then it may affect the whole class. 
         - So , One class , one functionality code can be easily maintained by this principle .
         - Ex: class Student{
               calculatePercentage();
               addStudent();
               printDetails();

               } 
         - Insted of writing all methods in one class , create seprate class for each method

         -> Open-Closed Principle
         +++++++++++++++++++++++++++
         - According to this principle the class should be open for extension but closed for modification.
         - extension means class allows us to implement new functionality  
         - closed for modification means class cannot allow to modify to avoid the functionality disturbance of same class

         -> Liskov Substitution Principle (LSP) this is related to inheritance
         ++++++++++++++++++++++++++++++++++++++
         - According to this principle  child classes must be completely substitutable for their parent classes.
         - ex: father is Engineer and son is Teacher and they both are from same family , In this we can't replace 
           father 

         -> Interface Segregation Principle
         ++++++++++++++++++++++++++++++++++
         -  According to the principle larger interfaces split into smaller ones.
         -  Because the implementation classes use only the methods that are required. 
         -  We should not force the client to use the methods that they do not want to use.
         -  The goal of the interface segregation principle is similar to the single responsibility principle. 
        
         ->Dependency Inversion Principle
         ++++++++++++++++++++++++++++++
         -  According to the principle we must use abstract classes and interfaces instead of concrete implementations.
         -  High-level modules should not depend on the low-level module but both should depend on the abstraction.
         -  Ex: Dependency Injection for loose coupling

         Solid Principles with example
         +++++++++++++++++++++++++++++++++
          1) class User {                                         Single Responsibility principe
                private int id;
                private String name;

                //setters and getters
             }
          2) interface UserService{                               Open Close Principle
               public User login();
          }
          3) interface Banking{                                   Interface segeration principle
             public void withdraw();
          }
          4) class UserServiceImpl implements UserService{        Liskov substutaion principle  
               @override
               public User login(){

               }
          }
          5) class UserController{                                Dependency Inversion principle
              @Autowired
              private UserService userService;
          }


        3) Explain LLD and HLD [ Which  Design patterns you used in your project ]
        ++++++++++++++++++++++
         -> Desing patterns means proven solution of common problems while developing the software applications
         => Yes , I work on design patterns , I dont indivisually design any patten from my side but yes I have hands on experience on internal Design patterns 
         1) Low Level Design : For design at the class and object level.
                               1) Singleton 
                               2) Factory 
                               3) Builder
                               4) Strategy 
         2) High Level Design: HLD patterns are commonly used in microservices, distributed systems, and enterprise applications.
                               1) Service Discovery
                               1) API Gateway
                               2) Circuit Breaker (Resilience4j)
                               3) Cache Design Pattern
                               // below I dont use in my project
                               4) CQRS (Command Query Responsibility Segregation)(Event Sourcing with Kafka)
                               5) Saga Pattern (Apache Camel)
                               
         
            1) Singleton Design Pattern
            +++++++++++++++++++++++++++
              -> This design pattern ensures that the class has only 1 instance all over the application
              -> It is used to develop the database connection , logging , caching class

            2) Builder Design pattern
            +++++++++++++++++++++++++
              -> This design pattern related to step by step object creation 
              -> It is Used when an object has multiple attributes and customization
              -> Car car = new Car.CarBuilder().setEngine("V8").setWheels(4).build();

            3) Factory Design Pattern
            +++++++++++++++++++++++++
              -> This design pattern related to object creation without created by us 
              -> IOC container created object for the bean class is example of Factory design pattern
            
            4) Strategy design pattern
            ++++++++++++++++++++++++++

            5) API gateway Design Pattern ( Spring Cloud Gateway )
             +++++++++++++++++++++++++++++
              -> API gateway is an single entry point for multiple microservices.
              -> Used to aggregate multiple APIs, authenticate requests, and apply rate-limiting.

             4) Microservices Design Pattern
             +++++++++++++++++++++++++++++++
             -> Insted of developing all the functionalities in single project , 
             -> We are dividing the functionalities into microservices
             
             5) Circuit Breaker Design Pattern
             +++++++++++++++++++++++++++++++++
             -> When any failure occurs in our microservice , insted of giving the error we can executing the fall back logic by using this circuit breaker.
             -> It is used to implement Falt tollerance system in our application

             6) API gateway Design Pattern
             +++++++++++++++++++++++++++++
             -> This is going to be manage all the Backend api's at one place by using Routing and Filtering  

             7) MVC Design Pattern
             ++++++++++++++++++++++
             -> Model-View-Controller (MVC) Pattern is one of the architectural patterns for creating web applications with loosely couplling

             8) Cache Design Pattern
             ++++++++++++++++++++++++++++++
             -> Cache Design Pattern we are using in our application by using Radis Cache
             -> It is used to implement the performance of the application
             -> Insted of getting data from the database every time we can store the data into the cache ad we can take the cache data to use in our application

             9) Strategy Design Pattern 
             ++++++++++++++++++++++++++++
             -> Strategy Design Pattern  is nothing but we are following the rules to develop our application with Interfaces 
             -> We are not using Inheritence to reuse the functionality of one class in the another class 
             -> We are using Interfaces to communicate  from one class to another class , that comes under Strategy Design Pattern 
 
             10) DAO design Pattern
             +++++++++++++++++++++
             -> Data Access Object  pattern
             -> when we design classes that communicate with databases.
             -> Then we seperate Service layer data and entiy layer data 

      4) What are the OOP principles
      +++++++++++++++++++++++++++++++++
      -> OOP is one type of programming which is based on classes and object insted of functions 
      -> Class  : class is one programming template and programming template consist of data and logic and that data and logic we are going to implement 
                  according to our requirement
      -> Object : Object is the instance of the class , it is  like a real time world existing things and It consists of 3 main characteristics Identity , properties and Functionalities
                  Identity: means to differentiate one object from another object
                  properties: means to hold the data for ex: like accNo, accHolderName , pin   
                  functionalities : is for doing some operation on properties like withdraw() , balanceEnquiry() , deposit()
      -> And it has 4 main principles i.e : Inheritance , Abstraction , Encapsulation , and Polymorphism
                                  
      1)Inheritance  : Inheritance means creating the new class form the existing class , so we can reuse the super class functionalities in sub class ,
                       and also we can create the new functionalities in sub class
                       here the parent class is called as super class and child class is called as sub class .
                       By using extends keyword we achive the inheritance in class and by using implements keyword we achive inheritence in interface
                       and in java types of Inheritance are
                       Single Inheritance : only one one super and sub class
                       Mutilevel Inheritance : having multiple sub classes 
                       Multiple inheritance : achive by using Interaface : super class reuse multiple times

      2) Abstraction : The process of hiding the internal implementation from the user and provide only the services those we are offering is Abstraction
                       We can achive the abstraction by using Abstract class and Interface  
                       Generally we use Interface : All methods in interface by default public and abstract
                                                    and variables public , static and final
                                                    form java 8 we can add default and static methods in interface

      3) Encapsulation :-> The process of Wrapping the data and code into the single unit is called Encapsulation 
                        -> In java encapsulation is achieved by declaring the instance variables of a class as private,so they can only accessed within the class.
                        -> ANd to access the variables outside , public methods called getters and setters which are used to retrieve and modify the values
                           of the instance variables
                        -> data hiding and abstraction we can achive 
                        -> private = for data hiding

      4) Polymorphism : -> When two classes have IS-A relation and One object refer both super class and sub class members then this is called as Polymorphism 
                        -> means one object have abality to take many forms 
                        -> One interface having multiple implementation classes is polymorphism example
                        -> Compile-Time Polymorphism: Achieved through method overloading (same method name with different parameters).
                        -> Runtime Polymorphism: Achieved through method overriding (subclass redefines a method of the superclass).

      5) What is difference between class and Interface
      +++++++++++++++++++++++++++++++++++++++++++++++++
      Class
      ----
         -> class keyword used to create.
         -> A class can be instantiated i.e., objects of a class can be created.
         -> Classes do not support multiple inheritance.
         -> It can be inherited from another class by using the keyword ‘extends’. 
         -> It can contain constructors.
         -> It cannot contain abstract methods.
         -> Variables and methods in a class can be declared using any access specifier(public, private, default, protected).
         -> Variables in a class can be static, final, or neither.

      Interface
      ---------
         -> interface keyword used to create an interface .
         -> An Interface cannot be instantiated i.e. objects cannot be created.
         -> The interface supports multiple inheritance.
         -> It cannot inherit a class by using the keyword ‘implements’ and it can be inherited by an interface using the keyword ‘extends’.
         -> It cannot contain constructors.
         -> It contains abstract methods only.
         -> All variables and methods in an interface are declared as public.
         -> All variables are static and final.


      6) What are your roles and responsiblities in your project  -> in Development and in Batch Programming
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      - My roles and responsibilities in IES application is 
      - first of all what ever the responsibilities that I get I analysis that requirement  then I go for design and development
      - I design the Component classes with the help of MVC design pattern and also I am responsibile for developning the persistence layer with the 
         help of spring Data JPA 
      - After developing the services , controller , entity classes I perform the code review with the help of SonarQube framework
      - I also involve in the unit Testing and Integeration testing 
      - Also I am going to support the SIT and UAT phases for if any code defect is there then for that defect fixing
      - On daily basis my responsibility is to send the notices to citizens email id for that we create one batch job 

       //- Basically we are developing the application i.e IES application , and this application we are developing 
        by using Agile technology
        - and what ever the requirement I get I analysis that requirement then I will do design and development 
        - I develop Component classes using MVC design patterns
        - I am also responsible to develop Persistence layer using JPA framework
        - On daliy basis I created the batch jobs to process the citizens notices 
        - I involve in the code review using Sonar Qube framework
        - I also invloved in the unit testing and integration testing
        - I support SIT and UAT phases for the defects fixing  
        - This are my roles and responsiblities in my project //

       7) What kind of work you are doing right now in your project
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       -> Bacially the RI state goverment added the new criteria for eligibilty for the citizens who allready applied for the plans and those 
          who are going to apply for the plan 
       -> For these eligibilty determination our team needs to update the code that Eligibility determination module we are udpating
          based on the RI state criteria

       8) What are your day to day activities in the Project
       +++++++++++++++++++++++++++++++++++++++++++++++++++++++
       -On a daily basis, I engage in the following activities:
      ---------------------------------------------------------
         1) API Development: Designing, implementing, and deploying APIs for various functionalities.
         2) Test Case Writing: Creating and maintaining unit and integration test cases to ensure code quality.
         3) Code Reviews: Reviewing code using tools like SonarQube to ensure compliance with coding standards and best practices.
         4) Testing Support: Assisting during SIT and UAT phases. Addressing bugs reported in JIRA and providing bug-free code.
         5) Email Notifications: Sending notifications to citizens' email IDs using the respective modules.
         6) Git Operations: Performing Git operations for code updates and version control.
         7) JIRA Updates: Documenting and updating the progress of the tasks on JIRA.
         8) Scrum Meetings: Attending daily Scrum meetings to discuss progress, blockers, and plans.

       In my day to day activities basically my day starts with 
        => My daily work start from 10 o clock am  , I login at 10 o clock 
        => and My scrum meeting is at 11 o clock
        1) On daily basis we have stand up calls which are arrange by our scrum master
           => where I expalain my yesterday and todays task status
           => What I have done yesterday and what today I am doing 
           => If any challenge I face at last I disucss 
           => or If the task is complete then the new task is allocated by the scrum master through JIRA or I will allocte that that for me 
        2) Also every day I have the eyes on the emails and messages on the teams apps 
           => any one is asking on any challenging work if they face on teams group channel 
           => Any meeting on calender
        3) If I face any challenge then I schedule a one to one call on teams  and discuss about that chellange
        4) Also daily I check the code update on git and perform the git operation accoirding to requirement

      9) How the task Is allocate for you 
      +++++++++++++++++++++++++++++++++++++++
       => On Jira the task are allocate for us 
       => If task is in To Do status then I allocate it on my name 
       => I confirm the status on jira as In Progress  
       => after the task is done then I review the code , perform Unit Testing
       => And after that I give the task status as ready to Test on Jire 
       => If any bug is issue form testing team I will solve that 
       => After the sit team gives Done status 
       => I will Save the status as Done for the task  

      10) What are the challenges you haved faced in your project
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> In our Application there is one Corresponding module is there , which sends the notices to the citizens email with plan details
         , when citizen successfuly apply for the plan
      -> Initial days this modules works properly as expected , but after few days , more traffic comes, and citizens have complaints that 
          they dont get notices on there email id 
      -> not getting notice on there email means citizens dont know they successfully apply for the plan or not .
      -> So this is one big issue that we face in our application.
          So how do you resolve that 
          --------------------------
      -> Actually we understand  , Before getting the issue whatever the logic we build to send the notices to citizens emails ,
          that send the notices one by one , means that module capacity is 3600 notices per hour 
      -> After identifying the issue we done some research and development and we implemented Multithreading in the project.
      -> we realize that notices are indipendent , one notice does not have relation ship with other notice , because every citizen 
           will have there own indivisual notice 
      -> So insted of executing notice generation logic with 1 thread , we have implemented multithreading in our project by using Executer services

      
	  11) Different Enviorments of one project
	  +++++++++++++++++++++++++++++++++++++++++
	  - In my project , total 5 Enviorment are there 

            1) Dev Env : Developers will use it for code Integration testing

            2) SIT Env : Testers will use it application end to end testing
                         ( System Integration testing also called as QA Enviorment )
            3) UAT Env : Client / Client Side Team will use it for acceptance testing.
                         ( User Acceptance Testing )
                           Note: In UAT client / client side team will decide GO or NO-GO
                              GO : Approved for Production deployment
                              NO-GO : Denied for Production Deployment
            4) PILOT Env : Pre-Prod Env for testing and they application with  live data
            5) PROD Env  : Live Environment (endusers will access from prod app) 
		
	  12) How many repository are available for your project
	  ++++++++++++++++++++++++++++++++++++++++++++++++++++++
	  - In my project repository is only one but branches are different
            - main / master(default) 
            - develop
            - feature
            - sit
            - uat
            - release .... like this 
        - Why this much brances - for parallel production

	  13) What are the annotations you know and you use in your application SIBEERRRRIA-PCCC(Siberia-PC)
	  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   	  1) SpringBootApplication :  This annotation is used with start class of the spring boot application
                                    This annotation is equals to 3 annotations @SpringBootConfiguration, @EnableAutoConfiguratio, @ComponentScan
                                    Without this annotation we cannot start our application
   	  2) ComponentScan  : to scan all base packages
   	  3) Entity         : To declare the class as Entity class ,so that class will communicate with data base
        4) Id             : To generate primary key value
        5) Service        : TO declare the class as Java Bean class , so IOC container manage the object
        6) RestController : To declare the class as Distributed class ,so it can handle the request response
        7) Component      : TO declare the class as Java Bean class , so IOC container manage the object
        8) Configuration  : If we want to create custom bean object for our method then that class must be declared with @Configuration annotation
        9) RequestBody    : SO method can take input as a form body
        10) RequestPath   : to take multiple variables as input from the URL path
        11) PathVariable  : To take input as parameter from the URL path
        12) RestControllerAdvice : TO handle the class as Global Exceptional Handler
        13) ExceptionHanlder : To declare the method as exception hanlder
        14) Bean          : If we want to create custom bean for our method then we use this annotation
        15) Autowired     : To perform dependency injection

		14) Explain your project architecture and its flow 
      ++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> IES application have total 26 modules , few of the modules I know 
      -> like  - Admin Module
               - Case Worker Module
               - Regestration Module
               - Data Collection Module
               - Eligibility Determination Module
               - Correspondence Module 
               - Batch Module
               - Benefits Issue Module
               - Reports Module
      -> Admin Module
         ++++++++++++
         -> Admin api responsibility is to Activate and DiActivate the accounts for the Caseworkers .
         -> and another responsibility of the Admin module is the Manage the Plans like
             -> Plan start date
             -> Plan end date
             -> Which plan is to activate this year
             -> Which plan is to diactivate this year
             Note Caseworkers cannot create account directly 
      ->Caseworker Module
        +++++++++++++++++
        -> This CaseWorkers api is operated by the Caseworkers to apply the plan for the citizens
        -> In Caseworker 
             - Caseworker Login
             - Edit Profile for Caseworker
             - Forgot Password for Caseworker
             - Regestration for citizen
             - How many Citizens REgister
             - How many citizens form is approved
             - How many citizens form is denied
      -> Application Regestration Module
        +++++++++++++++++++++++++++++++
        -> In this api the Caseworker can apply the plans to the citizens 
        -> Application Regestration api will collect citizen basic information and it will verify citizen belongs to RI state or not .
        -> Application Regestration api verify the citizen is from RI state goverment or not through SSA-WEB API 
        -> This SSN-WEB API is 3rd party api ( central goverment project )
        -> If citizen belongs to RI state then only Application Regestration api citizen to apply for the paln
        -> If citizen not belongs to RI state then Application will not created for citizen to apply for the paln
      -> Data Collection Module
       ++++++++++++++++++++++
        -> Data Collection api is responsible to collect the citizen data which is required to apply for the plan
        -> Citizens Data like
            1) Family details 
            2) Education details
            3) Employed details
            4) Income details
            5) Kids details etc
            Note : From UI screens we collect the data for this 
      -> Eligibility Determination
       +++++++++++++++++++++++++
          -> Eligibility Determination api is responsible to verify citizen data is eligible for the plan or not
          ->for  Different palans have different Eligibility criteria 
          -> If citizen data matches with plan criteria then citizen will be aprroved for the paln otherwise citizen plan will be denied 
          Note : Approved citizen will get benefits amount from the Govt.
      -> Correspondence Module
       +++++++++++++++++++++
          -> Correspondence Module api is responsible to send Notices( means PDF notice ) to citizens regarding their elegibility
          -> Notices like
              - Approved Notice
              - Denied Notice 
              - Termination Notice  if you terminated 
              - Plan renewal Remainder Notice , 15 , 30 , 60 days  remainder
              - Missing Documents Notice- birth certificate missig
          -> Notice nothing but one PDF document 
              - Hi congrulations , you apply for SNAP paln 
              - You got approved for this plan
              - your plan will start form this date  and end on this date 
              - monthly you are going to get this much amount 
              - Like that we generate one notice and send through PDF
           -> If application got denied that information also generate and send through PDF on mail
           -> remainder notices like your paln is comming to expire do you want to reniew that plan , for that come to DHS office and reniew that plan
      -> Benefits Issue Module
      +++++++++++++++++++++
         -> This api is responsible to send benefits amount to approved citizens
      -> Reports Module
       +++++++++++++++
          -> Reports api  is used to generate reports in excel/pdf format with application data 
             - Report Based on Plan Name
             - Report Based on Plan Status
             - Report Based on Duration (Start date and end date)
             - reports base on Citizen Gender 
          -> I want to get all the  people who applies for SNAP
          -> all data of Denied people 

		15) What is differece between Fail Safe and Fail Fast collections with example
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        => Fail Fast Collections will throw error immediately when we modify collection object while traversing the collection.
           Ex: ArrayList , LinkList , HashSet , etc
           Fail Fast Collection will throw error ConcurrentModificationException when we modified

        => Fail Safe Collections will not throw any  error if we modify collection object data (Add / Remove) whilw traversing 
           Ex : CopyOnWriteArrayList  , ConcurrentHashMap  , IdentityHashMap  ,  etc....
      
      what is difference between map and flatmap in java 8
      +++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> Both methods are available in Stream interface 
      -> Both methods are used for intermediate operations (means transforming one object form into another object form)
      -> map() method is only used for transformation of objet( one to one transformation ) ( one input one output)
      -> flatMap() is used for transformation and flatering (one to many transformation) ( one input multiple output)( ex : toList)

     16) Explain difference between String and StringBuffer and StringBuilder  
     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       
                                 String                              StringBuffer                          StringBuilder
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       1)Introduce             Java 1                                Java 1                                  Java 1.5
       ------------------------------------------------------------------------------------------------------------------------------------------
       2) Muatabilty           Immutable                              Mutable                                Mutable     
       ------------------------------------------------------------------------------------------------------------------------------------------
       3) Thread Safety        Thread Safe                           Thread Safe(multihtreading)             Not Thread Safe
       ------------------------------------------------------------------------------------------------------------------------------------------
       4) Performance wise     High(Async Synchronization)           Low(Due to Synchronization)             High(No-Synchronization)
       ------------------------------------------------------------------------------------------------------------------------------------------
       5) When to use          used when we want immutable string    used when Thread safety is required     used when Thread safety is not required
       ------------------------------------------------------------------------------------------------------------------------------------------
   
       immutable    : Not change any thing
       mutable      : can be change 
       Synchronize  : one thread at one time
       Asysnc       : multithread at one time
       Thread safe  : multithreading

      18) What id difference between Comparable and Comparator with example
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            Feature                      Comparable                       Comparator
            ================================================================================================
            Package                      java.lang                        java.util
            -----------------------------------------------------------------------------------------------
            Method                       compareTo(Object obj)            compare(Object obj1, Object obj2)
            -----------------------------------------------------------------------------------------------
            Sorting Logic                Defined in the same class.       Defined in a separate class.
            -----------------------------------------------------------------------------------------------
            Flexibility                  Less flexible (single property). More flexible (multiple properties).
            -----------------------------------------------------------------------------------------------
            Use Case                     Natural/default sorting.         Custom sorting.
            -----------------------------------------------------------------------------------------------

      19)  What are the different ways to create new thred
       +++++++++++++++++++++++++++++++++++++++++++++++++
           Feature              Extending Thread                  Implementing Runnable                Implementing Callable
           ===================================================================================================================================
           Method               run()                             run()                                call()
           ----------------------------------------------------------------------------------------------------------------------------------
           Return Type          void                              void                                 Object (via Future)
           ----------------------------------------------------------------------------------------------------------------------------------
           Exception Handling   Limited                           Limited                              Better exception handling (throws)
           ----------------------------------------------------------------------------------------------------------------------------------
           Multiple Inheritance Not supported                     Supported                            Supported
           ----------------------------------------------------------------------------------------------------------------------------------
           Use Case             Simple thread creation           Separation of task and thread logic   Result-oriented or complex tasks
           ----------------------------------------------------------------------------------------------------------------------------------

      20) What is difference Runnable and Callable interface in java
      -------------------------------------------------------
      => Runnable Interface
         ------------------
         -> If we implement Runnable interface then we have to override run () method which will not return anything.
         -> And also we need to create thread object every time which is not recommended
         -> ex: public class Demo2 implements Runnable{
                @Override
                public void run() {
                    System.out.println("run()- method called");
                }
                public static void main(String[] args) {
                    Demo2 d1 = new Demo2();
                    Thread t1 = new Thread(d1);
                    t1.start();
                }
            }
      => Callable Interface
         ------------------
         -> Callable interface introduced in java 1.5v 
         -> Using callable interface we can implement multi threading
         -> We will use Executors framework in order to deal with Callable interface.
         
         -> Ex: public class Demo4 {
             public static void main(String[] args) {
                 Demo4 d = new Demo4();
                 d.processNotifications();
             }
             public void processNotifications() {
                 List<Orders> orders = dao.getOrders();
                   ExecutorService executorService = Executors.newFixe dThreadPool(10);
                 for (int i = 1; i <= orders.size(); i++) {
                     executorService.submit(new Callable<Object>() {
                         @Override
                         public Object call() throws Exception {
                             sendNotification(orders.get(i));
                             return null;
                         }
                     });
                 }
             }
             public static void sendNotification(Order order) {
                 //get order details
                 // get customer details
                 // send email
                 // send wathsapp msg
                 System.out.println("sending email ...");
                 System.out.println("sending whatsapp msg...");
             }
         }


      21) What is the Exception Hierarchy and its types
      --------------------------------------------------
      => Throwable class is the root class for all the exceptions classes 
      -> In throwable class Exception class and Error classes are two main sub classes
      -> Exception means any unwanted or unexpected error that occurs during the execution of a program means at the run time of the program
         and this disrupts the normal flow of execution in the program’s .
      -> And Exceptions are divided into 2 Categories 
      -> One is Checked Exceptions and Second one is Unchecked Exceptions
      -> Checked Exceptions means exceptions are checked by the compiler while compiling the code
      -> This are mainly 1) IOException ,2) SQLException ,3) FileNotFoundException ,4) InterruptedException
      -> And Unchecked Exceptions means exceptions which are not checked by the compiler 
      -> Like  Arithmetic Exception, Null Pointer Exception ,IndexOutOfBoundsException ,IllegalArgumentsException
      -> IOException - File not found exception  

      -> Give the example of Error 
         - OutOfMemoryError: Thrown when Sometimes due to excessive object creation JVM has no memory to runs out
         - NoClassDefFoundError: Thrown when the JVM can't find a class that was available at compile time or at runtime.
         - StackOverFlowError - 
           Ex : public class Demo {
                void m1() {
                    m2();
                }
                void m2() {
                    m1();
                }
                public static void main(String[] args) {
                    System.out.println("main ( ) method - start");
                    Demo d = new Demo();
                    d.m1();
                    System.out.println("main( ) method - end");
                  }
               }
         

     22) What are the collections have used in your project 
     +++++++++++++++++++++++++++++++++++++++++++++++++++++
     - list . set and map , this are main 3 collection interface I have worked 
     - and in this interface i worked on ArrayList , HashSet and HashMap collections classes
      
     23) Differenc between ArrayList and LinkedList : Note Both are not synchronized
      -------------------------------------------------
      => ArrayList
         ---------
         -> ArrayList is the implementation class of list interface and available in java.util package
         -> ArrayList is used to store the object data in the list format where it used Dynamic Array as internal Data Structure
         -> Insertion order is maintain and data can also access in random format 
         -> We can also implement insert and delete operations on ArrayList but it is slow 
         -> For every new object memory is allocate in continous format

      => LinkedList
        --------------
         -> LinkedList is the implementation class of list interface and available in java.util package
         -> LinkedList is used to store the object data in the list format where it used Double Link List as internal Data Structure
         -> Insertion order is maintain but data cannot access in random format
         -> Data we cannot be access in random format because data is store in nodes and this nodes are connected left and right with another node
         -> Insert and Delete operation are fast with LinkedList 
         -> memory is not allocate in contionus format

      Common points with ArrayList and LinkedList
      -------------------------------------------
      -> classes of List Interface
      -> Duplicates allow 
      -> Nul allow
      -> Insertion order maintain

      22) Differenc between HashSet and LinkedHashSet :Note Both are not synchronized
      -----------------------------------------------
      => HashSet
        ---------
        -> It is the implementation class of Set interface and available in java.util package
        -> It uses Hashtable as data structure to store the object 
        -> Insertion order is not maintain in HashSet class
        -> It allocates low memory and performance wise it is faster than LinkedHashSet

      => LinkedHashSet
         ------------- 
         -> It is the implementation class of Set interface and available in java.util package
         -> It used Hashtable and DoubleLinked List data Structure to store the Object data 
         -> Insertion order is maintain in LinkedHashSet class 
         -> It allocates more memory and Low performance than HashSet because it uses two data structure

      Commom points 
      --------------
       -> Both implements from Set interface
       -> Dublicates are not allowed
       -> only one null is allowed
       -> Both are non synchronized means not thread safe
       -> Both uses Hashing technique to store the data


      23) Difference between HashMap and LinkedHashMap
      -------------------------------------------------
      => HashMap
         --------
        -> It is the implementation class of Map interface and available in java.util package
        -> It uses Hashtable as data structure to store the object in key and value format 
        -> one null key and multiple null values can store in HashMap
        -> Insertion order is not maintain in HashMap 
        -> it uses less memeory and it is fast than LinkedHashMap

      => LinkedHashMap
         -------------
         -> It is the implementation class of Map interface and available in java.util package
         -> It uses Hashtable and DoubleLinkedList as data structure to store the object in key and value format
         -> one null key and multiple null values can store in HashMap
         -> Insertion order is maintain in HashMap 
         -> it uses more memeory and it is slow than HashMap
      Common Points
      ------------
        -> Both implements from Map interface
        -> Both store data in key and value format , one key can null , multiple null values can be
        -> Both are non synchronized means not thread safe

      24) What is difference between TreeSet and TreeMap
      --------------------------------------------------
      TreeSet
      -------
         -> It is an implementation class of set interface and it internally uses binary tree as data structure
         -> TreeSet internally uses natural sorting order to store the data and also we can use custom Comparator provided at the time of creation
         -> In TreeSet nulls are not allows because of natural sorting order
      
      TreeMap
      -------
         -> It is an implementation class of Map interface and it internally uses binary tree as data structure
         -> TreeMap is used to Stores data in key-value pairs, where each key is unique
         -> data is stored in natural sorting order based on the keys’ only or based on a custom Comparator provided at the time of creation
        

       Common points
       -------------
         -> Both uses Binary Tree as a Data Structure 
         -> By default, their elements are sorted by natural ordering. 
         -> Since the elements are already sorted the access and retrieval time becomes faster. 
         -> key cannot allows as null , Value can be Null.
         -> They are defined inside ‘java.util’ package.
         -> Both support Comparable Interface that can be implemented to define a custom sorting order
      
      25) Difference between HashMap and HashTable
      --------------------------------------------
      Hashtable
      ---------
       -> Every Method Present in Hashtable is Synchronized. 
       -> At a Time Only One Thread is allowed to Operate on the Hashtable Object and Hence it is Thread Safe.
       -> Relatively Performance is Low.
       -> null is Not allowed for Both Keys and Values. Otherwise we will get NPE. 
       -> Introduced in 1.0 Version and it is Legacy.

      26) Differenc between HashMap and IdentityHashMap
      --------------------------------------------------
       -> The IdentityHashMap uses equality operator (==) to compare the key and value
       -> while the HashMap uses the equals() method to compare key and value inside the Map.
       -> As the IdentityHashMap doesn't use equals() method it is faster than the HashMap.
       -> IdentityHashMap doesn't require keys to be immutable as it is not dependant on equals().

     
      
      27) What is difference between Interface and abstract class
      -----------------------------------------------------------
      Abstract class
      --------------
       -> Abstract class can have abstract and non-abstract methods.   
       -> Abstract class doesn't support multiple inheritance.
       -> Abstract class can have final, non-final, static and non-static variables.
       -> Abstract class can provide the implementation of interface. 
       -> The abstract keyword is used to declare abstract class.
       -> An abstract class can extend another Java class and implement multiple Java interfaces.
       -> An abstract class can be extended using keyword "extends". 
       -> A Java abstract class can have class members like private,protected, etc.
       -> 9)Example:
              public abstract class Shape{
              public abstract void draw();
               }

      Interface
      ---------
       -> Interface can have only abstract methods. Since Java 8,it can have default and static methods also.
       -> Interface supports multiple inheritance.
       -> Interface has only static and final variables.
       -> Interface can't provide the implementation of abstract class.
       -> The interface keyword is used to declare interface.
       -> An interface can extend another Java interface only.
       -> An interface can be implemented using keyword "implements".
       -> Example:
              public interface Drawable{
              void draw();
              }
 
     
      28) What are the methods available in Object class
      --------------------------------------------------
       => Object class available in java.lang.Object package and provide multiple methods like
       -> Object class methods are available to all Java classes. Hence Object class acts as a root of inheritance hierarchy in any Java Program.
            Method                                   Description
            ================================================================================
            toString()             If we want to print the object then object is print in the String format because it called toString() internally | s1 or s1.toString()
                                   If we want to print object data then we need to override String class to String method
                                   Student s = new Student(1 , "Nilesh");
                                   Sysout(s) => Student@12db3213f    
                                   Sysout(s.toString());
            --------------------------------------------------------------------------------
            hashCode()             It will Returns a hashcode value of the object.  
                                   Hashcode is a unique identification number which holds address of the object. Ex: 388776355
                                   we can create our own hashcode
                                   s1.hashCode() => 388776355
            --------------------------------------------------------------------------------
            equals()               Compares objects refrences i.e hashcode equal or not of 2 object
                                   if we want to compare content then override String class equals()
                                   String s1 = new String("Nilesh");
                                   String s2 = new String("Nilesh");
                                   s1.equals(s2) = true 
                            Note: StringBuffer s1 = new StringBuffer("Nilesh");
                                  StringBuffer s2 = new StringBuffer("Nilesh");
                                  s1.equals(s2) => false //why 
                                  because StringBuufer class not override equals method
            --------------------------------------------------------------------------------
            clone()                If we want to copy the object for backup use then we use this clone method 
                                   rules to use this clone method
                                   1) class implements form cloneable interface
                                   2) method throws CloneNotSupportedException
                                   Cloning are 2 types 1) shallow clone 2) Deep Clone
                                   1) Shallow clone : Student s2 = s1    // use with primitve datatypes | properties are override in cloning so afftected | 
                                   2) Deep clone    : Student s2 = (Student)s1.clone()  // use foe both refrence or primitive datatype | properties are not override
            --------------------------------------------------------------------------------
            getClass()             If we want to know the particular object belongs to which class , which package then we use this getClass() method
                                    s1.getClass().getName() => ashokit.Student
                                    s1.getClass().getSuperclass() => class java.lang.Object
            --------------------------------------------------------------------------------
            finalize()             Called before garbage collection for cleanup (deprecated). not use from java 9
            --------------------------------------------------------------------------------
            wait()                 Causes the current thread to wait until notified.
            --------------------------------------------------------------------------------
            notify()               Wakes up one thread waiting on the object's monitor.
            --------------------------------------------------------------------------------
            notifyAll()            Wakes up all threads waiting on the object's monitor.
            --------------------------------------------------------------------------------



      29) What are the changes in java 8 explain   java 8 2014 -> total 10 changes
      ------------------------------------------(FILM CD SOSS)--------------------
      -> In java 8 the most important changes are lamda ex, stream api, interface changes , functional interface , optional class , method ref
       ->   1) Interface changes
               1: Default Methods
               2: Static Methods
            2) Functional Interface                        // so this are the important changes they have done in java 8
               1: Predicate
               2: Consumer 
               3: Supplier
               4: Function
            3) Lambda Expression 
            4) Method Refrence and Constructor Refrences
            5) Stream Api    MMMMIMP ***** for Experience
                 After data store in collection then to process the data we use Stream API
            6) Optional class ( to avoid null point exception because null point exception is very comman )
            7) Parallet stream
            7) Spliterator ( special iterator)
            8) StringJoiner
            9) Collection FrameWork changes
            10) Date and Time api

      30) Expalin nullPointerException in java
      -----------------------------------------
      => - When we perform some operation on null value then we will get NullPointerException
         - If we get Exception means our application is abnormally behave
         - To avoid NullPointerException we have to implement null check before performing operation on the Object like below
              String s = null;
              s.length()  // NPE
              if(s! = null){
                 sysout( s.length);
              }
          note: In the project there is no gaurantee that programmer will implement null checks.   
          If any body forgot to implement null check then program will run into nullPointerException
          To avoid this problem we need to use Optional class 

      

      31) Explain Optional class in java
      -----------------------------------
      =>-> optional means data may available , data may not available
        -> if we dont use Optinal class , then we get data directly to perform operationa
        -> if we use Optional class then we dont get data directly , we get data in object format
        -> we write complex logic but forgot basic logic then no use of complex logic
        -> java.util.Optional class introduced in java 1.8 v.
        -> Optional class is used to avoid NullPointerExceptions in the program
        -> when we perform any operation on null value then we get NullPointerException
           ex :  userName.toUpperCase();  
           here userName is getting null from DB and we perform operation on that user 
        -> getting  NullPointerException is very common in real project
        -> before Optional how developer check NullPointerException
           ex:
            if(userName=null){
                String msg = userName.toUpperCase();
            }else{
                Sysout "Invalid userName"
            }
            // but every developer us not a good programmer who can check the null value  , so java people introduce in Optional class to avoid this exception
        -> In Optional class data is present in Object format , we cannot get direct data 
        -> we need to check first data is present or not then get that data
             isPresent() - to check data is present in Optional object 
             get()       - to get object data and perform the operation
             Note in get() also gives you object data only  
             if(userName.isPresent()){
                 userName.get();   // object data only
                 String name = userName.get();
                 sysout(name.toUpperCase());  // operation is perform
              }
     32) Difference between method OverLoading and Method Overriding -> 8 points each 
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      =>Method Overloading
      --------------------
       -> If two or more methods with the same name and with different parameter list then it is said to be method overloading
       -> In method overloading return type can be same or can be different
       -> Methods can be overloaded in the same class also
       -> Methods can be overloaded in inheritance also
       -> In Method overloading , access modifier can be same or different
       -> final , static ,private methods can be overloaded
       
      => Method Overriding
      --------------------
       -> If two or more methods with the same name and with same parameter list then it is said to be method overiding
       -> In method overriding return type must be same except co-varient return type
       -> Methods cannot be overeiden in the same class because ambiguity to call
       -> Methods can be overriden in inheritance only
       -> In Method overriding , overriding methods can have same access modifier or less restrictive access modifier (Must not be more restricitve)
       -> final  methods cannot be overridden because final keyword used to prevent method overriding
       -> Static  methods cannot be overridden because static members do not require object to call
       -> private  methods cannot be overridden because private members cannot be inherited

      
      
      --------------------------------------
   33) Explain Functional interface in java
      ----------------------------------------
      -> Functional interface is an interface which has only one abstract method. and that interface is annoted with @FunctionalInterface 
      -> It can have any number of default methods, static methods, and methods inherited from the Object class.
      -> The primarily used of Functional Interface is used to invoke the lambda expressions, 
      -> Another implement a functional interface is used for method references, which allow you to refer to an existing method 
         that matches the signature of the interface's abstract method.
      -> Predicate , Consumer , Supplier , Functional these are the common Functional inteface
      -> Predicate -> It is used to check condition and return true or false value. , Predicate<Integer> p= i -> i>10 , sopln(p.test(5)) , output : true
         Consumer ----------> will take input           -------> will not return anything => accept() as abstract method
         Supplier ----------> will not take any input   -------> returns output => get() as abstract method
         Function ----------> will take input           -------> will return output  => apply() as abstract method

   34) 
   35) What is Lambda expression in java
   ++++++++++++++++++++++++++++++++++++++
   -> Java is called as OOP language , Everything will be represent using Classes and object . 
   -> But From 1.8v onwards Java is also called as Functional Programming Language because of Lambda expression
   -> In OOP Language Classes and object are main entities . we need to write methods inside the class only.
   -> Functional Programming means everything will be represent in the form of functions .
      Functions can exist outside of the class . 
      Function can be stored into a refrence variable . 
      A function can be passes as a parameter to other methods.
   -> Lambda Expression introduced in java to enable Functional Programming.
   -> Lambda function is store in variable , that variable belongs from Functional Interface
   -> Lambda is an anonymous function ( means function without name)
        -No Name ,No Modifier , No Return Type
        () -> {}  , () method ,-> arrow bind () and {},{} body
   -> To call the Lambda function -  Functional Interface is use  , because Lambda is anonymous function

   36) Expalin the Fail Safe Collections IdentityHashMap , ConcurrentHashMap ,WeakHashMap
   --------------------------------------------------------------------------------------
   =>
   37) What is different between ConcurrentHashMap and HashMap

  38)What Are HTTP Status Codes? Explain
      +++++++++++++++++++++++++++++++++++
      -> Every REST API method should be mapped to HTTP Method if that method is provider or consumer
      -> Http methods are mainly 4 they are get,post ,put and delete
      -> When client send the request to server then along with the data server is also send the status code 
      -> There are 5 main types of status codes 
      -> Status code which are start form 100 to 199 they are related to Information(Information provide sucessfully)
                                          200 to 299 - related to Success (OK) ( get successfully response from server to client)
                                          300 to 399 - Redirection  (we send request to one server and that server send your request to another server)
                                          400 - 499  - Client Error
                                          500 - 599  - Server Error
        ->  200   OK                    [your request is process successfully]
        ->  201   Created               [ for post request we use , reuest process and created]
        ->  204   No Content            [request is processed but server nothing to return]
        ->  400   Bad Request           [incorrect information you are sending]
        ->  404   Not found             [URL is incorrect ]
        ->  405   Method not allowed    [request method is bind to get but you are sending post request]
        ->  406   Not Acceptable        [server providing json but you are accepting xml]
        ->  415   Unsupport Media Type  [ what ever the content we are sending that is not supported by server]
        ->  500   Internal Server Error  

      ----------------------------------------------------------------------------------------------------------------
      18 imp status codes 
      ---------------------
      - 200 OK: Request succeeded
      - 201 Created: Resource created
      - 202 Accepted: Accepted request
      - 204 No Content: Accepted request
      - 301 Moved Permanently: Accepted request
      - 302 Found: Temporarily moved
      - 304 Not Modified: Not modified
      - 400 Bad Request: Bad request error
      - 401 Unauthorized: Needs authentication
      - 403 Forbidden: Access Forbidden
      - 404 Not Found: Resource Not Found
      - 405 Not Allowed: Method not allowed
      - 408 Request Timeout: Request timed out - request time out to send the
      - 500 Internal Server Error: Server error
      - 501 Not Implemented: Not implemented
      - 502 Bad Gateway: Bad gateway error
      - 503 Service Unavailable: Service unavailable
      - 504 Gateway Timeout: Gateway Timeout
      ----------------------------------------------------------------------------------------------------------------

  39 What is Maven , its use , its goals , terminology used in maven , scope of maven , Repository of maven  
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ->  www.mvnrepository.com
       ->Maven is one build tool , Build tool because it is used to automate -  project build process" in the form of
       -> WIth the help of maven we can 
          a) downloading the dependencies and configured that dependencies automatically.
          b) Compile sourece code 
          c) Execute unit test cases (JUnit) 
          d) package application into jar or war 
             jar - for stand alone application
             war - for web application
       -> Maven is developed using java language
       -> The main aim of maven is to simplify java projects build process.
       -> Maven goals
          ----------- 
          mvn clean package => clean + compile + test + package  
          mvn clean install => clean + compile + test + package + install
          - clean  : delete our .class files
          - compile : to compile our source code  
          - test : to perform unit test cases
          - package  : to package in jar or war file
          - install  : to install the dependency  into our local repository from artifact repository,
       -> Maven Terminology
       ---------------------
            1) Archetype : Type of project (quick-start / web)
            2) groupId : Organization Name (in.ashokit)
            3) artifactId : Project name
            4) version : SNAPSHOT / RELEASE
            5) packaging : jar or war
            6) dependencies : libraries (jars)  
            7) Repositories : dependencies location 
       -> Maven repositories 3 types
        -----------------------------
            1) Central Repository (public)  
            2) Remote repository (private -> company specific)(Nexus/Jfrog)
            3) Local Repository (in our machine) -> .m2
       -> Maven Dependency Scope  decide when maven should load that dependency into our application.
        -------------------------
            compile    : dependency added at compile time
            runtime    : dependency added at run time
            test       : dependency added when unit test is happent
            provided   : provided means at what time dependenct to provide at compile or at runtime
            system     : system means a jar we want to load only
            import     : when one project import dependecy from another project then we go for import
       -> Maven dependency exclusion concept.
        -------------------------------------
         -> if we want remove some child dependencies then we need to use dependency exclusion
            <exclusions>
               <exclusion>
                  <groupId>org.springframework</groupId>
                  <artifactId>spring-aop</artifactId>
               </exclusion>
            </exclusions> 
       -> How to customize project build jar or war name ?
         -------------------------------------------------
                             
    40) What is Git and What are the Git commands you use in your project
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       Git : - GIT is one Version Control Software , And it is used to integrate the all source code of the application at one point
       ----- - And for to access this repository those who have monitor access only they can access this repository to download the code , change the code 

             - Version Control Software means One Project have multiple developers 
             - And this multiple developer are working from multiple location like India , australia , america etc ..
             - To integrate all the developers code at once place and To monitor/track their code changes
             - for  that we Version Control Softwares like GIT , Bit Bucket etc
             - In git hub we create the project repo and store source code at once place 
             - Anyone cannot access the Project source code because of monitored access. 
       GIT Architecture : 
       ------------------
             - Working Tree      : git init        
             - Staging Area      : git add . ( dot means all files in staging area)( for specific git add pom.xml)   
             - Local Repository  : git commit -m ' first commit' (-m represent message  for commit)      
             - Central Repository: git push -u origin main
                                   Note : if 1st time push , execute this 3 commands execute only one time
                                   git branch -M main   // this 3 commands execute only one time
                                   git remote add origin git@github.com:NileshNangde/App1.git
                                   git push -u origin main
       GIT Commands :
       ---------------
             - git help   : to get all  common commands 
             - git init   : To initialize working tree   
             - git add .    (dot is compulsory) : To add files to staging area
             - git status : To check staging area status
             - git commit : Send files from staging area to local repo
             - git push   : To push latest changes from local repo to remote repo
             - git pull   : To get latest changes from central to local
             - git restore: To discard working tree changes & to unstage the file
             - git clone  : To download central repo to local machine
             - git log    : To get repo commit history
             - git rm     : To remove file (rm + commit + push)
             - git branch : to  check which is your working branch
         MIMP Diff
         ---------
               1)  git clone vs git fetch
               2)  git push  vs git pull
               3)  git stash   and git stash apply
               5)  git merge  vs  got rebase
               git clone :
               -----------
                -> It downloads entire repository (including its history) from the remote server to your local machine.
                -> It is used when we first-time setup of a repository on your system.
               git fetch :
               -----------
                -> It downloads the latest changes from the remote repository into your local repository without merging them into your working directory.
                -> The changes are stored in the .git directory until we explicitly merge them using commands like git merge.
               git push :
               ----------
                -> This command sends our committed changes from the local repository to the remote repository.
                -> Requires write access to the repository.
               git pull :
               ----------
                -> This command Fetches and merges changes from the remote repository into your local branch.
               git stash :
               -----------
                -> THis command is used for Temporarily saves changes in your working directory that are not ready to be committed.
                -> This is useful when you need to switch branches or work on something else without losing your current progress.
                -> uses Case :   Suppose I am working on Bug 128 from 9 AM to 11 AM. Suddenly, you are assigned to work on a high-priority Bug 130.
                                 Use git stash to save the uncommitted changes of Bug 128.
                                 Switch branches to fix Bug 130, commit, and push the changes.
                                 Use git stash apply to restore your work for Bug 128.
               git stash apply :
               -----------------
                -> this command is used to Restores the stashed changes back to the working directory without removing them from the stash.
               git merge :
               ------------
                -> This command is used to Combines two branches, preserving the history of both branches.
                -> Creates a new commit called a merge commit.
               git rebase :
               --------------
                -> This command Reapplies commits from a branch on top of another branch to create a linear history.
                -> Eliminates merge commits.
                  Key Difference:
                  git merge maintains the complete history, showing all merge points.
                  git rebase rewrites history to create a cleaner, linear commit structure.
               git conflict
               -------------
                -> A conflict occurs when Git cannot automatically merge changes between branches or between the local and remote repositories.
                -> This typically happens if:
                     Two people modify the same line in a file.
                     One person deletes a file while another modifies it.
                ->Resolution for git conflict :
                     Git marks the conflicted files in the working directory.
                     Manually edit the files to resolve conflicts.
                     Add the resolved files using git add.
                     Commit the changes using git commit.


  41) Explain what is Agile Technology
  +++++++++++++++++++++++++++++++++

    Agile:  -> Software are develop with the help of SDLC process.
    -----   -> SDLC contains several phases like Requirements Gathering , Requirements Analysis , Designing , Development ,Testing ,Deployment ,Support
            -> The SDLC methodologies are Waterfall (outdated) and Agile  (trending)
         Waterfall Mode: Develop softwares in linear format , client involment is less , so client not happy
         --------------
         Agile Model   : -> One apporch to develop software in parallel process 
         -------------   -> In Agile model ( planning + development + testing + deployment ) is a continuos process.
                         -> Project functionalitiy will be divided into multiple sprints/releases. // this sprint are going to releases and deploy
                         -> Client involvement , feedback is very important is Agile model.
                         -> Requirements & Budget is not fixed in Agile.
         Agile Team      1) Product Owner  : Responsible for client deliverables.
         ----------      2) Scrum Master : Responsible to manage the team.  [  Product owner and Scrum Master both are Non tech MBA background]
                         3) Tech Lead : Responsible for solving technical challenges.
                         4) Team members : developers + testers (Note: Industry standard agile team size is 7 to 10 only.)
                           Every agile team will have one tech lead & one scrum master.
                           One project can have multiple agile teams also.(like ticket booking  one agile team , payment gateway one tem)
         Agile Terminology   1) Backlog Grooming     : meeting in which we discuss pending works in the project.
         -----------------   2) Story & Story Points : every pending work one story will be created in jira,Story points represents duration to complete the story.
                                                       3 points 1 day  or sometimes 1 points 1 day depending the task
                                                       5 points => 2 days
                                                       8 points => 3 days
                             3) Sprint Planning      : meeting in which we will discuss about priority stories to complete. 
                             4) Sprint               : means fixed set of stories targeted to be completed in given time.
                             5) Scrum                : Scrum call is a meeting in which we will discuss agile team work updates.
                                                       1) What i am doing 2) Status of my story 3) When it will complete 4) Any challenges to complete
                             6) Retrospective or     : meeting in which agile team will discuss about previous sprint which we completed.
                                Retro meetings         Note: Retro happens monthly once.  
                                                       Retro is like a review meeting. in retro we will discuss
                                                      - what went well
                                                      - what went wrong
                                                      - what lessons we learnt
                                                      - what new ideas we get

  42) Explain where you use JIRA Software
   ++++++++++++++++++++++++++++++++++++++
       -> Acutually development is 1 part and management is 1 part 
       -> JIRA is project management software 
       -> We are use JIRA for
          1) Bug Tracking      : Streamlines the reporting and fixing of bugs during development cycles.
          2) Team Collaboration: team collaboration through comments and shared updates , this visibility of project activities can track by stakeholders 
          3) Project Reporting : Provides stakeholders with clear and accurate reports on project status.
        
  43) For What purpose you use SonarQube in your application
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      ->  SonarQube is a software tool which is used for automated code review and quality analysis purpose
      -> code reviews are 2 types 1] using software : SonarQube 2] Peer review - fresher code review by senior team member)
      -> The main Purpose of SonarQube :
          1) Code Review : 
              Automates the process of reviewing code to identify potential issues.
              Complements manual peer code reviews, which are conducted by senior team members, especially for fresher code.
          2) Improving Code Quality
               Helps ensure code quality by enforcing best practices and identifying issues early.
               Produces a clean, maintainable, and bug-free codebase.
               Key Issues Identified by SonarQube
          3) Bugs: Detects errors that could cause runtime issues.
          4) Vulnerabilities:(वल्नरेबिलिटी ) => improper validation -> this cause security risks
          5) Code Smells: Highlights areas where code quality is compromised, like unused imports or repeated strings.
          6) Duplicate Code Blocks: Detects copy-paste issues, which can lead to maintenance challenges.
          7) Code Coverage: Measures the percentage of code tested by unit tests (target: 80%).
      -> Note : SonarQube will not check our logic is correct or not , it will check are we following the best practice of java to develop the application or not

      -> How SonarQube Communicates With the Application
         ------------------------------------------------
          -> Integration With Jenkins Pipeline
          -> The SonarQube server is configured within the Jenkins pipeline.
          -> Developers trigger a Jenkins pipeline build, which automatically analyzes the code and pushes the results to SonarQube.
          -> Viewing SonarQube Reports
          -> Developers access the SonarQube dashboard to review detailed code analysis reports.
             Reports include information about bugs, vulnerabilities, code smells, duplications, and code coverage.
          ->Fixing Issues
            Based on the SonarQube report, developers address the identified issues in the code.
            The fixes are re-analyzed in the next pipeline run to confirm resolution.
            Tasks Typically Assigned to New Joiners (First 3 Months)
            Sonar Fixes

            Resolve issues flagged by SonarQube, such as code smells, vulnerabilities, or duplicate blocks.
            Implement Unit Test Cases

            Write JUnit test cases for untested code to ensure functionality.
            Improve Code Coverage

            Increase the project's code coverage to meet the expected threshold (e.g., 80%).
            Bug Fixing

            Address existing bugs or issues in the application.

  
  44) How do you find the runtime cause / troubleshooting of your application    Note : if bug not solve : Tanay Pratap youtube 
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> If application is in development stage then I find the runtime cause using debugging of the application or logging 
      -> If applciation is in production then runtime cause I find using reading the log files 
      -> Step by step applcaiton execution details/flow  I will write into the log files using logging
      -> like user login -> client type his username , password , hit login , request send to controller class , data fetching from data base
      -> like this step by step execution we are writing into the log files with the help of loggig

      -> Note : if company is small then , we can call the directly client /customer and take those details what he face




   45) Suppose application is abnormally terminate in production then How do you find runtime root cause of your application OR
       what is Logging and why and its levels 
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
    -> In my application the runtime root cause of the application is managed by Logging concept and the execution details are store in log files
    -> and with the help of logging we can identify root cause of the exception. Log4J framework we use for logging
    -> Logback  , this is default logging framework used in spring boot to generate log messages and INFO is the default level
    -> Logging Architecture is divided into 3 parts 
    ->   1) Logger    -> This is one class which provides methods to write log msgs
                      -> ex : trace(), debug(), info(), warn(), error()
                      -> private Logger logger = LoggerFactory.getLogger(MsgService.class); ( 1st create logger object For every java class )
                        @Service
                        public class MsgService {
                           private Logger logger = LoggerFactory.getLogger(MsgService.class);
                           public String getWelcomeMsg() {
                              logger.info("getWelcomeMsg() - started...");
                              String msg = "Welcome to Ashok IT";
                              logger.info("getWelcomeMsg() - ended....");
                              return msg;
                           }
                        }
         2) Layout    -> This represents log msg pattern in the form of data,time,log-level,class-msg,thread etc..
         3) Appender  -> THis Appender represent on which destination the log msg are to print in ConsoleAppender or in FileAppender 
    -> What are the diff Logging Levels  -> Log msgs will be stored to log file based on log level
    ------------------------------------ 
         -> TRACE  : is used to store every line execution details
         -> DEBUG  : is used to store execution flow at low level      DEBUG => DEBUG + INFO + WARN + ERROR
         -> INFO   : is used to store execution flow at high level     INFO  => INFO + WARN + ERROR
         -> WARN   : is used to store warnings in code execution flow  WARN  => WARN + ERROR
         -> ERROR  : is used to store execptions occured in code flow
         -> Note: In springboot, default log level is INFO.  
    -> How to change log level in the application using below property
     --------------------------------------------------------------
         -> logging.level.root = WARN
    -> How to print log messages in file 
    ------------------------------------
         -> logging.file.name=app.log   in app.properties
    -> What is Logging with Rolling
    ------------------------------
         -> Rolling is one mechanism , and this mechanism is used to avoid to make the large files of log messagees
         -> basically what happent when we store the log messages in file then day by day files size is going to big 
            and this file is not open , or load , or having lot of log messages
         -> To avoid this problem Rolling mechanism introduce and it is implemented by 2 ways 
         -> 1) Size Based Rolling   -> upto 1 GB log file size reach new file crated
            2) Time Based Rolling   -> to create every day new log file
            // Reamining  -> How to do this
    -> What is the diff between SLF4J and Log4J ?   and what are the diifferent logging framework you know 
    ---------------------------------------------
         -> SLF4J -> means Simple Logging Facade for Java (SLF4J)
         -> This is java library which is used by different logging framework( like Log4J , logback)
         -> Because of this library we make log messages loosely coupled to our appication

         -> Log4J -> Logging framework to track the application we the help of log messages
            ------
    -> What is Log Monitoring
    --------------------------
         -> Our application is running on Linux machine , and if any runtime error cause in application , 
         -> To find the root cause of that abnormal termination of the application we tract the log messages which are available in log files 
         -> Reading the Log messages means Log Monitoring 
         -> To read the Log messages we use diff tools /applications like Putty / MobaXtream , ELK , splunk etc , I use MobaXtream

  45) What is Testing , Isolated testing , Integration testing , Unit testing , JUnit , Code Coverage , Mocking
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        -> Testing  : Testing we do to test the component functionality code is working properly or not as we designed , and give bug free code to higher testing Enviorment
          ----------  or the Process of verification and validation is called as Testing.
        -> Isolated Testing :  same as Unit testing , controller service not call service class service , testing only controller service indivisually
          -------------------- 
        -> Integration Testing : means entire application end to end flow testing
          ----------------------
        -> Unit Testing : Testing individual components of the application ex: one controller method 
          --------------- As a developer I am responsible for Unit testing , to provide Bug free code for higher Enviorments Like SIT , UIT etc
        -> Junit  :  Java Framework to perform Unit Testing  ,Junit 5 v for testing java 8 and above
          ----------
        -> AsserJ  :
          ---------
        -> Code Coverage : For code coverage we need to add external Jacocco dependency , this provide the UI which represent how many lines are executed in Unit testing
          ---------------- Industry standard is minimum 80% code coverage for the project.
        -> Mocking :  To write the test cases we use Mockito object , insted of controller call service it call mockito 
          ----------- Mocking means  the  process of creating substitute object for real-object is called as Mocking.
                      To perform mocking we have mocking framework - Mockito  Framework . 
                      Mokito 3.x v for java 8 and above 
         Annotations used in unit Testing and how to run test cases
         -----------------------------------------------------------
                -> 1) @Test - represent method as Unit test method
                -> 2) @WebMvcTest(Controller = msgController.class)  when controller class represent Unit test
                -> 3) @SpringBootTest - ( for service , Dao class or normal class ) to represent class as unit test class
                -> 4) assertEqual(expectResult , actualResult) - to verify actual result with expect result 

                - Run Unit test program as Junit test 
                - green color means test successs
                - red means fail
       
         Note: 'spring-boot-starter-test' dependency to perform unit testing. , By default added

         How to perform Unit testing for the REst API in the Spring 
         ------------------------------------------------------------
         How to perform unit testing for private methods 
         -----------------------------------------------  

   46) What is performance testing and what is JMeter
      +++++++++++++++++++++++++++++++++++++++++++++++
         ->  Process of verification and validation is called as Testing.
         ->  Software Testing will happen in multiple stages
            1) Unit Testing                 :- Testing individual components of the application , Developers will perform unit testing using Junit.
            2) System Integration Testing   :- Testing team will perform system integration testing. Team Identified bugs will be reported using JIRA.
            2) System Integration Testing   :- 
            3) Performance Testing          :- Checking application stability and responsiveness.
            4) User Acceptance Testing      :- client or client side team will test our application before delivery
                                               Note: Based on UAT client will decide GO or No-GO.
                                               Go means it is green signal from client to deploy in production.
                                               No-GO means client identified some issues in UAT hence production deployment got cancelled.


         -> Performance Testing : Checking application stability and responsiveness.
           --------------------  For ex :
            1) how many users can access at time ?
            2) for 100 users what is avg response time ?
            3) for 1000 users what is avg response time?
            ....
            4) for 1 lakh users what is avg response time?
            5) what is bottleneck/failure-point of the app ?
         -> Note: To implement performance testing we will use tools  Ex: JMeter, HP Load Runner    

         JMETER
         ------
         -> JMETER is a free & open source software given by Apache Organization
         -> JMETER is used for performance testing
         -> Performance testing means the process of verifying stability & responsiveness of the application
         -> How our application is responding for different work loads we can verify using JMETER
         -> Using JMETER we can create virtual users to test our application performance
         -> JMETER is a java based desktop application
         -> Using JMETER we can test performance of any web application
         Note: We can't implement performance testing manually
            What is the response time of our application for 100 users ?
            What is the response time of our application for 200 users ?
            What is the response time of our application for 300 users ?
            What is the response time of our application for 400 users ?
            What is the response time of our application for 1000 users ?

         -> We need to provide application performance details to client
         -> If application performance is slow then we need to troubleshoot the issue and we need to fix it.

   47) What is Exception and How do handle exception in your REST API's
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Exception : ->  Exception means runtime error in our application due to this application flow of execution is disturb 
   ----------  -> and application behave like abnormally
               -> TO handel this runtime error for that exception handling comes into the picture 
             Traditional approch:
             --------------------
               -> The traditional way to handle the core exceptions we are using try , catch , throw and throws clauses 
               -> In this technique the execution logic added in try block and if any exception then catch by catch block
               -> But problem in this exception handling is , it is not going to be send the meaning full responce to the client 
               -> Suppose I want to find the user through its id and that id is not present then it shows Internal server error  
               -> this is not meaning full error that client can understand 
               -> To give meaningfull error response for that we need to create an ErrorResponse class where we added proper message , details 
               -> And Through SpecificException class which extends from RuntimeException like ProductNotFount we can send the proper message to client 
               -> But here also problem is , in another API suppose I need to handle the same exception then I need to copy paste the exception code 
               -> Due to this the code dublication in the same class and maintaince problem is cause 
             @ExceptionHandler approch:
             --------------------------
               -> IN this approch we can create the controller specific exception handler to handel the exception
               -> FOr that class annotate with @ExceptionHandler() and in this annotation we are pass the the exception class name 
                  for which we want to handle the exception like @ExceptionHandler(ProductNotFound.class)
               -> Now the Rest api's which are available in the same class can handle by ProductNotFoundException
               -> But problem is we have another class having rest api's then that class not use this @ExcetpionHandler 
               -> To avoid this issue @ControllerAdvice annotation we can use to handle the exception globally
             @ControllerAdvice approch : 
             ---------------------------
               -> In this approch the controller specific exceptions can be call by all the rest api's available in different classes 
               -> This is Global exception handler approch to handle the exception
               -> For this we need to create one method in Global Exception class and this method annotate with @ExceptionHandler(ProductNotFound.class)
               -> ANd with this ExceptionHandler annotation we are going to call the specific exception class to handle the exception
               -> Here 2 annotations we can use @ControllerAdvice or @RestControllerAdvice
               -> @Controlleradvice for MVC application  here @RequestBody annotation we cannot use to send response through ResponseEntity 
               -> @RestControllerAdvice for Rest API to send error response through ResponseEntity , and inbuild @RequestBody annotation

             Note: In Rest api all the custom Exception are call by the controller classes only and Custom exception present into the GLobalException class
                
           What is an Exception?
           +++++++++++++++++++++
            An exception is a runtime error that occurs during the execution of an application, causing it to behave abnormally and disrupting the normal flow of execution. Exception handling mechanisms are used to manage these errors gracefully, ensuring the application continues to run or provides meaningful feedback to the client.

            Traditional Exception Handling
            ------------------------------
            The traditional way of handling exceptions uses try, catch, throw, and throws clauses.
            The application logic is placed in the try block, and potential exceptions are caught in the catch block.

            Problems:
            =========
            Generic Error Responses: Traditional exception handling often results in generic error messages (e.g., "Internal Server Error"), 
                                     which are not helpful for the client.
            Code Duplication       : Exception-handling logic often needs to be repeated across different APIs, leading to maintenance challenges.

            Solution:
            ========
            Create an ErrorResponse class with meaningful error details (e.g., message, timestamp, status).
            Use custom exceptions extending RuntimeException (e.g., ProductNotFoundException) to provide specific error messages.

            Modern Exception Handling Approaches in REST APIs
            ++++++++++++++++++++++++++++++++++++++++++++++++
            1. @ExceptionHandler Approach
            -----------------------------
                     Handles exceptions in a specific controller class.
                     Use the @ExceptionHandler annotation to map an exception type to a handler method in the same class.
                     Example:
                     -------
                     @ExceptionHandler(ProductNotFoundException.class)
                     public ResponseEntity<ErrorResponse> handleProductNotFoundException(ProductNotFoundException ex) {
                         ErrorResponse errorResponse = new ErrorResponse("Product not found", LocalDateTime.now());
                         return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
                     }
                     Limitation:
                     This approach is limited to the controller in which the exception handler is defined. Other controllers cannot reuse the handler logic.

            2. @ControllerAdvice Approach
            ------------------------------
                     Handles exceptions globally across all controllers in the application.
                     Define a global exception-handling class annotated with @ControllerAdvice or @RestControllerAdvice.
                     Example:
                     -------
                     @RestControllerAdvice
                     public class GlobalExceptionHandler {

                         @ExceptionHandler(ProductNotFoundException.class)
                         public ResponseEntity<ErrorResponse> handleProductNotFoundException(ProductNotFoundException ex) {
                             ErrorResponse errorResponse = new ErrorResponse("Product not found", LocalDateTime.now());
                             return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);
                         }

                         @ExceptionHandler(Exception.class)
                         public ResponseEntity<ErrorResponse> handleGeneralException(Exception ex) {
                             ErrorResponse errorResponse = new ErrorResponse("An error occurred", LocalDateTime.now());
                             return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);
                         }
                     }

            Key Points:
            ---------

            @ControllerAdvice is used for traditional MVC applications . Cannot use @RequestBody for responses.
            @RestControllerAdvice is suitable for REST APIs. Combines @ControllerAdvice with @ResponseBody to send error responses as JSON.
            
            Summary:
            -----------
            Traditional Approach:
            Limited to individual APIs and lacks meaningful error messages.

            @ExceptionHandler:
            Handles exceptions for specific controllers but is not reusable across controllers.
            
            @ControllerAdvice/@RestControllerAdvice:
            Provides a centralized, reusable, and global exception-handling mechanism, ideal for modern REST APIs.
            Using these modern techniques ensures that REST APIs return meaningful and consistent error responses to clients while reducing code duplication and improving maintainability.






  4
  

  50) Explain the difference between Callable interface and Runnable interface
  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    -> In Java both Callable and Runnable interfaces are designed in such a way that they are going to be execute the single tasks on multiple threads 
    -> Here in 
    -> Runnable Interface 
    ----------------------
         -> The Runnable interface is designed in such a way that it is going to execute the task on multiple threads but the run() method 
            does not Return a value or any outcome: The task's 
         -> Means the task is  success or failure is not communicated directly to the caller.
         -> available in java.lang package
         -> It have public void run() method which is not return any result when thread is executed
         -> The run() cannot throw any checked exceptions
         -> And this Runnable interface is suitable for those operations where result oriented is not required ex :notifications to send 
         -> It works with both Thread and ExecutorService Framework
    -> Callable Interface 
    ------------------------
         -> The Callable interface is designed in such a way that it is going to execute the task on multiple threads and the call() method 
            Return a value or any outcome
         -> Means if the task is  success or failure is  communicated directly to the caller.
         -> available in java.util.concurrent package
         -> It have public V call() method which throws checked Exception
         -> call() method return type is Future object either primitive data type or Object 
         -> It works on ExecutorService and Future 
         -> It is  suitable for tasks where a result oriented or exception handling is required.
    -> Runnable Interface code
    ---------------------------- 
             class MyRunnableTask implements Runnable {
                   @Override
                   public void run() {
                       System.out.println("Task is running using Runnable!");
                   }
              }
             public class RunnableExample {
                   public static void main(String[] args) {
                       Thread thread = new Thread(new MyRunnableTask());
                       thread.start(); // Executes the task
                   }
               }
    -> Callable Interface code
    --------------------------
              class MyCallableTask implements Callable<String> {
                   @Override
                   public String call() throws Exception {
                       return "Task completed and returning result using Callable!";
                   }
               }
            -------------------------------------
               public class CallableExample {
                   public static void main(String[] args) throws Exception {
                       ExecutorService executor = Executors.newSingleThreadExecutor();
                       Callable<String> callableTask = new MyCallableTask();

                       // Submit task and get Future
                       Future<String> future = executor.submit(callableTask);

                       // Get result from Future
                       String result = future.get();
                       System.out.println(result);

                       executor.shutdown(); // Shut down the executor
                   }
               }
   51) What is ExecutorService Framework 
   ++++++++++++++++++++++++++++++++++++++
      -> ExecutorService is an tool / Framework available in java.util.concurrent package and it is used for managing and controlling threads
         in preffered order in multithreding
      -> ExecutorService is going to be simplifies the thread management like how threads are created, managed, and executed.
      -> ExecutorService provide services like 
          -> Thread Pool Management:
             It manages a pool of threads, reusing them for executing multiple tasks, which improves performance by avoiding the
             overhead of creating and destroying threads repeatedly.
          -> Task Submission:
             TO submit tasks for execution using methods like execute(), submit(), or invokeAll()
          -> Result Handling:
             For both Runnable and Callable tasks it allows tasks to return results and handle exceptions via Future objects.
      -> TO use the  ExecutorService , 
            Rule 1 : create ExecutorService , Executor provide method like
                     For Single-threaded Executor: ExecutorService executor = Executors.newSingleThreadExecutor();
                     FOr Fixed Thread Pool:        ExecutorService executor = Executors.newFixedThreadPool(4); // 4 threads
                     For Cached Thread Pool:       ExecutorService executor = Executors.newCachedThreadPool();
                     For Scheduled Thread Pool:    ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
            Rule 2 : Submit Tasks
                    -> execute() - for Runnable Interface 
                    -> submit()  - for both Runnable/Callable
                       submit() Executes a task and returns a Future to retrieve the result or handle exceptions


  52) Explain @RequestBody Annotation detailly
  ++++++++++++++++++++++++++++++++++++++++++++

  53) Explain Transient Keyword  with Coding Example
  +++++++++++++++++++++++++++++++++++++++++++++++++++
  => To understand Transient keyword , first we need to understand what is Serilization and DeSerilization
  -> Serilization :  means java class variables data  means java class object data is convert into byte and store into file format  
  ------------------ here JVM convert this objectdata into byte format 
  -> DeSerilization : means reverse of Serilization , file byte data is convert into Java object format 
  ------------------
  -> Now Transient means : When we declare the variable with Transient keyword then , during Serilization JVM not convert that varible data into 
                           byte format , JVM store the default values in the Serilization process 
  -> This Transient key we use , whenever there is 1) any Securuty consern in data , 
                                                   2) Data that should not be saved in serilization
                                                   3) Any Temporary data 
  -> Demo Example 
  -----------------
   public class Student implements Serializable{

       public int studNo;
       public String studName;
       public String studResult;
   -------------------------------
   public class SerializationDemo{
        public static void main(String[] args){
        Student s1 - new Student();
        s1.studNo=5;
        s1.studName = "Nilesh";
        s1.studResult = "fail";

        String fileName = "D:\\nilesh\testfile.txt";
        try{
        FileOutStream fos = new FileOutputStream(fileName);
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s1);

        oos.close();
        fos.close();
        }catch(FIleNotFoundException e){
           e.printStackTrace();
          }catch(IOException e){
             e.printStackTrace();
            }
         }
   }
   ------------------------------------
   public class DeSerilizationDemo{
       public static void main(String[] args){
       String fileName = "D:\\nilesh\testfile.txt";
       try{
       FileInputStream fis = new FIleInputStream(fileName);
       ObjectInputStream ois - new ObjectInputStream(fis);

       Student obj = (Student).ois.readObject();
       System.out.println(obj.studNo);
       System.out.println(obj.studName);
       System.out.println(obj.studResult);

       oos.close();
       fos.close();
        }catch(FIleNotFoundException e){
           e.printStackTrace();
          }catch(IOException e){
             e.printStackTrace();
            }
         }
   }

  54)  Explain Volatile Keyword in java
  +++++++++++++++++++++++++++++++++++++
   -> When we declare the variable as volatile then the , then this volatile variable is directly store the value into 
      the main memory not in cache memory . to avoid the inconsistency in data
   -> We have 3 memories like Cache memory , main memory(Ram) and and Hard Disk 
   -> Suppose in my account I have 500Rs allready , and I want to pay 1000Rs to some one , I call my family to send me 500 Rs 
   -> so my father send me 500 Rs , now in my CPU thread 1 is execute , and in cache memory it store 1000RS
   -> Now again my Mom also send me 500RS , for that in my CPU thread 2 execute and it store 1500RS in cache memory
   -> Now I pay 1000 RS to some one for that Thread 1 is executed and it read the thread 1 cache memory and minus 1000 and remains 0 as balance
   -> Now here inconsistency of data occur because data is not read from main memory , so each Thread which execute is not read data from main memory
   -> If I declare the variable as Volatile then each thread is going to be directly communicate with main memory not in cache memory
   -> So inconsistency of data is not going happent 

  
                
   56 ) How to perform Unit testing for the REst API in the Spring 
   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   -> To performt the Junit testing for REST api classes for that 

  57) WHat is difference between Monolithic Applications and Microservices Architecture based Applications
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      Aspect             |  Monolithic Application                |   Microservices Application
      ===================================================================================================
      Architecture       |  Single unit                           |   Multiple independent services
      ---------------------------------------------------------------------------------------------------
      Scalability        |  Limited (entire app scales together)  |   High (scale services independently)
      ------------------------------------------------------------|--------------------------------------
      Deployment         |  Single deployment for all features    |   Independent deployment of services
      ------------------------------------------------------------|--------------------------------------
      Single point failure| Entire app may fail                   |   Localized failures (fault isolation)
      --------------------------------------------------------------------------------------------------
      Technology Stack   |  Uniform                               |   Diverse (polyglot architecture)
      --------------------------------------------------------------------------------------------------
      Database           |  Centralized                           |   Decentralized (per service)
      --------------------------------------------------------------------------------------------------
      Development Speed  |  Slower as the app grows               |   Faster with independent teams
      --------------------------------------------------------------------------------------------------
      Maintenance        |  Challenging for large apps            |   Easier for modularized components
      --------------------------------------------------------------------------------------------------
      Communication      |  Internal                              |   External (via APIs, queues, etc.)
      --------------------------------------------------------------------------------------------------

      When to Choose Which?
      --------------------
      Monolithic Applications:
      -----------------------
      Best for small to medium-sized applications.
      Suitable when the application doesn't require frequent scaling.
      Easier for small teams with limited resources.

      Microservices Applications:
      --------------------------
      Ideal for large, complex, and evolving systems.
      Necessary when different parts of the system have varied scaling and technology needs.
      Suitable for teams experienced in distributed systems.


 

 59) What is difference between private static final and public static final when to declare and when to use
 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     private static final : 
                         Ex: private static final ModelMapper mapper = new ModelMapper();  => here mapper object is only to be initialize 
                             private static final Logger logger = Logger.getLogger(Service.class.getName());
                             private static final String BASE_URL = "https://api.example.com";

     public static final :
                         Ex:
                             public static final String INTERNAL_SERVER_ERROR : "internal_server_error";
     -> private static final : use when we want to encapsulate implementation details and prevent them for external misuse.
     -> public static final  : use when we want to declare the constants that need to be shared across multiple classes 
                               or represent part of a public API.
                                

  

 60) How interservice communication you do in Microservices
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   -> Interservice Communication we can done using 3 ways 
   -> 1) RestTemplate 
      2) Web-Client 
      3) Feigh-Client

      Feigh Client prefer for interservice communication because it uses module name , insted of URL to communicate to another Microservice module


 61) Explain How you Handle traffice in you application 
 ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    -> Using LoadBalancer 
    --------------------------
          - With the help of load balancer we can distribute the load on different server to avoid the server crashing
          - here RPM ( request per minute ) is there means our application is popular and more request comes at a time 
          - In this senario we need to create multiple INSTANCES of the one application ( one application running on multiple server means instance)
          - Here LBR ( load balancer ) comes into picture which is going to handle the traffic in Round Robbing fashion ( means one by one server load)
          - In this senario Database is same , only we are our application jar file on different server
      -> If we are using load-balancing to handle RPM then we are creating multiple instances , means we are running our applciation on different server
      -> In this situation for interservice communication we need to only use Fiegn Client because 
      -> BEcause Fiegn Client uses Module name , not url for interservice communication 
      -> Feign Client take url from service registry through RIBBON ( it is part of feign client and this is Load Balancer)
      -> Ribbon load different url with round ribbon fashion( one by one url server load like 1 then 2 then 3 like )
      -> Note: without service registry we cannot achive Load balancing

      -> Note : 1) CLient side load balancing : using loadBalancer  :-FC decides which server want to hit
                2) Server side load balancing : using Kubernate     : AWS decides which url to load   => Horizontal pod auto scaling concept (learn)
                ex: flipkart big billion day

      -> How to run 1 application on different port number to achive load balancing
      ------------------------------------------------------------------------------
         1) right click on app  , run as RUN CONFIGURATION
         2) go to ARGUMENTS
         3) in VM ARGUMENT type -> -Dserver.port=9091
            This port we pass dyncmically   
         @Autowired
      -> private Enviorment enviorment (to get port number so we can understand )

           String portNum = enviorment.getProperty("server.port");


 62) Expalin API Gateway in Microservices 
 ++++++++++++++++++++++++++++++++++++++++
     -> If our application is Microservices based application and whenever Client send the request to any one of the microservice 
     -> then because our application is microservices based application then request does not goes directly to the microservice
     -> First that request goes to the API Gateway
     -> In the API Gateway the request is 
          => Filter -> like all security logic we write in api gate way only
          => Route  -> to call the specifice Rest api 
     -> Filtering for executing some logic before request processing and after request processing
     -> Routing tell the request is goes to which REST api
     -> To create the API Gate way Spring cloud have 2 approch 1) Zuul Proxy(old) 2) Spring Cloud Gateway(new)

   -> Steps to develop API Gateway application
   --------------------------------------------
      1) create spring boot app with gateway and eureka  dependency
      2) Register API gateway to service registry for for Routing purpose
      3) @EnableDiscoverClient  so service register can register automatically
      4) Configure ROutings in yml file
      Note : API Gateway must be communicate with the Serice Registry for Routing purpose 

   => YML file configuration
   --------------------------
         application.name : 
         server.port :
         spring.cloud.gateway.routes.=> -id:( Module Name )          // but can any
                                         uri : lb://WELCOME-API        (lb= load  balancing )   // this takes url of the service from service registry
                                         predicates: -Path=/welcome  // url name 
                                    // same for another
                                         -id:( Module Name )
                                         uri : lb://WELCOME-API   (lb= load  balancing )
                                         predicates: -Path=/welcome

 
  63) What is Actuators and what are the important Actuators urls you know 
  ========================================================================
       -> In Spring Boot framework, actuators provide production-ready features to help us to monitor and manage your application.
       -> This actuators provides built-in endpoints that we can use to monitor and interact with our application.
       -> Actuators are used to monitoring our applcation for 24/7  
       -> TO enable Acutator in our aplication we need to add dependency in our application spring-boot-starter-actuator
       -> 1) http://localhost:8080/actuator/health
                   Description: Shows application health information.
                   Usage: Useful for checking if the application is up and running.
          2) /actuator/info:
                   Description: Displays arbitrary application info.
                  Usage: Can be used to show custom information about the application, such as version, description, etc.
          3) /actuator/metrics:
                  Description: Shows metrics information for the application.
                  Usage: Useful for monitoring various metrics like JVM memory usage, system CPU usage, etc.
          4) /actuator/env:
                  Description: Exposes properties from Spring’s ConfigurableEnvironment.
                  Usage: Useful for inspecting the environment properties and configuration.
          5) /actuator/loggers:
                  Description: Shows and modifies the configuration of loggers in the application.
                  Usage: Useful for dynamically changing the logging level at runtime.
          6) /actuator/httptrace:
                  Description: Displays HTTP trace information (by default, the last 100 HTTP request-response exchanges).
                  Usage: Useful for tracing HTTP requests and responses.
          7) /actuator/threaddump:
                  Description: Performs a thread dump.
                  Usage: Useful for diagnosing threading issues.
          8) /actuator/mappings:
                  Description: Displays a collated list of all @RequestMapping paths.
                  Usage: Useful for inspecting the URL mappings in the application.
          9) /actuator/beans:
                  Description: Displays a complete list of all the Spring beans in your application.
                  Usage: Useful for inspecting the Spring context and the beans that are loaded.
          10) /actuator/configprops:
                  Description: Displays a collated list of all @ConfigurationProperties.
                  Usage: Useful for inspecting the configuration properties and their values.
          11) /actuator/scheduledtasks:
                  Description: Displays the scheduled tasks in your application.
                  Usage: Useful for inspecting the scheduled tasks and their configurations.
          12)/actuator/shutdown:
                  Description: Allows the application to be gracefully shutdown (not enabled by default).

Usage: Useful for triggering a graceful shutdown of the application.
            http://localhost:8080/actuator/health
            http://localhost:8080/actuator/loggers
            http://localhost:8080/actuator/threadump
            http://localhost:8080/actuator/beans
            http://localhost:8080/actuator/configProps
            http://localhost:8080/actuator/mapping

  64) Explain how Memory management in java 
  +++++++++++++++++++++++++++++++++++++++++
     -> In java JVM is responsible for memory management 
     -> In JVM runtime area is there where 5 memory area's are there 
     ->  Method area :  responsible to create the memory for static members
         Heap Area   :  responsible to create memory for instance members and all objects 
         Thread Area :  responsible to run execution logic on thread
         PC Register :  responsible to maintain the instruction of currencty executed class details 
         Native Stack:  responsible to maintain the informations related to native platform
     -> Also in java Execution engine is there which contains Garbage collector
     -> Garbage Collector is responsible for automatic garbage collection , means unused objects are destroyed by this garbage collectors automatically
     -> Just before destroying any object Garbage Collector always calls finalize() method to perform cleanup activities.

        Explain JVM Architecture
        ------------------------
       -> JVM is divided into 3 main ares 
       -> 1st is ClassLoader -> which is responsible to load the .class files from the specific folder 
                                Application class loader : responsible to load custom .class file if availble and load then it load Bootstrap and Extension class loader
                                Bootstrap class loader   : load predefine libraries like lang , util ,etc
                                Extension class loader   : extension libraries load
       -> 2nd is RunTime Area -> JVM have 5 memory areas
       -> 3rd is Execution Engine
           JIT compiler            : compiles bytecodes to machine code at run time and improves the performance of Java applications.
           Garbage Collector       : to clear objects memory from heap area
           Native method libraries : for executing native methods

        What are most HotSpot are in JVM related to performance
        --------------------------------------------------------
       -> Heap memory , Garbage Collectors and JIT compiler

        What is the role of JVM to make java as platform independent language?
        ---------------------------------------------------------------------
       -> Application byte code is Executed by JVM on the Operating system, so JVM make application as Platform independent
       -> Note but for this JVM is platform dependent

        What is Memory leaks in java
        -----------------------------
       -> In any application , Object is created but  that objects are not used by the application and that object is also not eligible for by the Garbage Collectors
       -> In this senario Memory leaks problems came into picture because this object are not destroyed by the Garbage collectors 
       -> Due to this memory leakage problem our application can crashed due to memory leakage problems.
       -> if memory leakage cames upto certain point then it JVM will throw OutOfMemoryException. 
       -> Hence it is highly recommended that if object is not in use then it is elegible for Garbage collectors
       -> By using monitoring tools we can identify memory leaks.

       What is difference between JDK , JRE and JVM
       --------------------------------------------
        JDK :
         - JDK means Java Development Kit
         - JDK = JRE + JVM.
         - and the use of JDK in the system is for developing,compiling and running Java programs

         JRE (Java Runtime environment)
         - JRE provides the environment for running/executing of programs
         - JRE contains-JVM , class libraries and other supporting libraries.

         JVM (Java Virtual Machine)
         - JVM is the virtual machine on which java code executes.
         - JVM is responsible for converting byte code into machine specific code.


  

  67) Expalin the difference between Method Overriding and Method Hiding in java
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       What is method overriding?
       ---------------------------
         => Defining more than one method with same name same return type and same arguments but one in super class and another
           one in sub class is known as Method Overriding.
          this can be achieved in super and sub classes.
              ex: class Parent {
                                  public void  m1(){ sopln(){ " parent "}}
                               }
                  class Child extends Parent{
                                public void m2(){solpn(){" child "}} 
                               }
                   ->  Parent p = new Parent()   ->  parent
                  ->   Child c = new Child() -> child 
                  ->   Parent p = new Child() -> child

       What is method hiding?
       ------------------------
          -> If both parent and child class method are static method with same name , same return   
             type and same parameters then this is called method hiding
          -> here in this method hiding - method object we create and store in those refrence object 
             based on that refrence the method will called
             ex: class Parent {
                                 public static m1(){ sopln(){ " parent "}}
                              }
                 class Child  {
                               public static m2(){solpn(){" child "}} 
                              }
                  -> ex: Parent p = new Parent()   -> parent object store in parent refrence -> parent method 
                  -> ex: Child c = new Child() -> child method called
                  -> Parent p = new Child() -> child object , but parent refrence -> parent method called

      What is difference between Method overriding and Method Hiding
       -----------------------------------------------------------------
         -> If both method are non static method and  method name,method return type , method parameter are same then it is called method overriding
         -> If both method are static and method name , method return type ,method parametr are same then it is called method hiding

  68) Explain Profiles/Profilers in java
  ++++++++++++++++++++++++++++++++++++++
     -> We use multiple enviorment to test our application working properly or not before going to its poduction
     -> In my company we have development , testing , production , uat etc this are the testing enviorments where we test our application
     -> But problem in this while testing the application into each machine the we need to manually change the application.properties file 
     -> In this any one of the property is configured properly the is error is enviorment testing error not developer error 
     -> To avoid this SPring profiles they introduces 
     -> In this we can create seperate application.properties file ex
         application-dev.properties
         application-sit.properties or application-qi.properties
         application-uat.properties
         application-pilot.properties
         application-prod.properties
     -> And this properties we are activating in main application.properties file like # Activating dev profile # then  # spring.profiles.active=dev #
     -> this one line change of code represents application should load properties from Dev properties file.
          

  69) What is Runners in Spring Boot
  ++++++++++++++++++++++++++++++++++++++
    -> After just execution of run() we want to execute some logic then we use Runner 
    -> Any setup logic if we want to execute at the end of the run method of spring boot application then we use runner
    -> To implement this runner Spring boot application provide 2 Runner interface and both uses are same
         1) ApplicationRunner inteface 
         2) CommandLineRunner inteface
    -> Both runners are functional interface. They have only one abstract method i.e run (..) method
    -> Use cases of Runners are
      1) send email to management once application started
      2) read data from db tables and store into cache memory
    -> Difference between Command line Runner and Application Runner
       Command line Runner:
          -> execution logic executes when through command line arguments passess by the application
          -> This arguments are the simple raw data in the form of arrays of String format
       Application Runner :
          -> execution logic executes when through application object is passed as the argument
          -> This object is well structured as key and value format

    ->  @Component
         public class CacheManager implements ApplicationRunner {

             @Override
             public void run(ApplicationArguments args) throws Exception {           run() have object as arguments 
                 System.out.println("Logic executing to load data into cache....");
             }
         }

         @Component
         public class SendAppStartMail implements CommandLineRunner {

             @Override
             public void run(String... args) throws Exception {           // run() have String array arguments 
                 System.out.println("logic executing to send email....");
             }
         }

   70) You mention Linux in your resume , Explain where do you use this LINUX 
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> We are using TimeBaseRolling to store the application execution details for that we are using LOG4J framework
      -> And this Logging file is available on cloud in the format of FileAppender
      -> To get this file for Log Monitoring purpose we are using Linux
      
      -> Linux cmd that I used are 
          - Head   :- to get top 10 lines from the file |  head m1.txt
          - Tail   :- to get bottom 10 lines            |  tail m1.txt
          - Grep   :- to find the specific text in the text file | grep 'java' m1.txt | grep -i 'java' m1.txt  -> ignore the case sensitive | grep -i 'java' * 
          - pwd 
          - touch  :- to create empty file  | touch nilesh.txt
          - cat    :- to create empty file , add content , display content 
                       cat > m1.txt   -> to create and add data into file 
                       cat m1.txt     -> to display data from file
                       cat >> m1.txt  -> to edit the file  again
                       cat > m1.txt   -> data override if we use this
          - ls     :- to list the content in directory
          - cd
          - whoami :- to get machine name 
          - mkdir
          - rmdir
          - vi     :- to open the file in visual editor mode 
                      press i to insert
                      press esc and then :wq   to save the data
                                          :q!   without saving

   71) What is difference between Throw and Throws keyword in java
   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

   72) What is Generics in java
   +++++++++++++++++++++++++++++
     -> This Generic introduce in java 1.5 
     -> And with the help of this Generic We can create class , interface and method as Generic
     -> In generic <>(angular brackets ) are there where we pass the parameter as dataType which provide type safety 
     -> Type Safety means at compile time its shows error if we dont store same data , like string datatype then only string data
     -> Ex : typeSafety : List<Integer> = only integer can store this is type safety
     -> High level Generics gives us 2 advantages is Code reusibility , code safety at compile time
     -> 1) Generic class :
                          - When we declare class as generic then that class can hold any kind of objects,
                          - to create Generic class we have to specify generic type <T> after the class name
     -> 2) Method        :
                          - Mostly I used this with collections
                          - List , Set , Map
     -> 3) Interface     : not use
     ->  Wildcards (?) in Generics
     -------------------------------
         1) Unbounded Wildcard     :  <?>
         2) Upper Bounded Wildcard :  <? extends Number>
         3) Lower Bounded Wildcard :  <? super Integer>

   73) Explain Shallow Clonning and Deep Cloanning in java  : - I dont work on it
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> Shallow Clonnig : - means creating new object from original object , where the clone object uses the same internal shared memeory
                           - here refrence is copid and used by clone object
                           - If we modify clone object then it also modify original object
                           - Automatically copy by super.clone() 
                           - Suitable for immutable objects.  
                     Implementation
                     --------------
                           - To implement shallow cloning , we need to implement  Cloneable interface into the class 
                           - and override clone() method which is provided by Object class

      -> Deep Clonning   : - means creating new object from original object , where both original and clone object have seprate memory
                           - if we modify clone object it is not change original memory
                           - We need to manual copying of internal objects.
                           - Suitable for mutable objects.

   74) Explain Garbage Collections in java
   ++++++++++++++++++++++++++++++++++++++++
      -> In Java Garbage collector is responsible for deleting un-used object or un-referenced object.
      -> To delete this un-used or un-refrence object in java programmer no need to work on this , JVM automatically delete this objects 
         whose refrence is lost
      -> There are few ways where object refrence got lost ex Employee empObj = New Employee("Nilesh")
      -> 1) empObj = null , means nullify - eligible for garbage collection
      -> 2) empObj create but not use outside method then - eligible for garbage collection 
      -> How  finalize() method utilize =>   When Garbage collector delete the object then compiler execute finilize() method 
      -> This finilize method contains some actions to delete the object

   75) Explain Reflection API in Java
   ++++++++++++++++++++++++++++++++++

   76) Explain Multi-Threading in java
   ++++++++++++++++++++++++++++++++++++
      ->  Multithreading :  Multi-threading in Java allows concurrent execution of two or more threads, enabling efficient utilization of CPU resources. 
          ---------------
      -> 1) Single Tasking
         -------------------
              Single-tasking means only one task is executed at a time. For example, a program that performs one operation after another without overlapping.
      -> 2) Multi-Tasking
         ----------------
              Multi-tasking allows multiple tasks to execute simultaneously. It can be categorized into two types:
      -> Thread-Based Multi-Tasking: Multiple threads within the same application share the same memory space.
         ---------------------------
              For example, a web server handling multiple client requests simultaneously.
      -> Process-Based Multi-Tasking: Multiple applications run simultaneously on the same operating system. For example, running VS Code and Chrome at the same time.
         ---------------------------
      -> 3) Advantages of Multi-Threading
         --------------------------------
            Better CPU Utilization: Threads allow idle CPU time to be used effectively.
            Faster Execution: Tasks can be divided into smaller threads for parallel execution.
            Improved Responsiveness: Applications remain responsive even during long-running tasks.
      -> 4) Main Thread
         --------------
            Every Java program has a main thread created by the JVM.
            The main() method runs in the main thread.
            By default, the main thread has a priority of 5 (NORM_PRIORITY).
      -> 5) Life Cycle of a Thread
          --------------------------
            New: Thread is created but not started. (call)
            Runnable: Thread is ready to run and waiting for CPU time.(ready to run)
            Running: Thread is executing its task.(Executing)
            Waiting: Thread is waiting for a resource or another thread.(waiting for another thred)
            Terminated: Thread has completed its execution.(execution complete then terminate)
      -> 6) Thread Priority
         ------------------
            Each thread has a priority between 1 (MIN_PRIORITY) and 10 (MAX_PRIORITY).
            By default, a thread has a priority of 5 (NORM_PRIORITY).
            Higher-priority threads are more likely to get CPU time.
      -> 7) Creating User-Defined Threads
         --------------------------------
            Extending the Thread class: Override the run() method.
            Implementing the Runnable interface: Implement the run() method and pass it to a Thread object.
            Implementing the Callable interface: Similar to Runnable, but it can return a result and throw exceptions.
      -> 8) Data Inconsistency Problem in Multi-Threading
          -----------------------------------------------
            When multiple threads access and modify shared data simultaneously, it can lead to inconsistent results.
            This is due to a lack of proper synchronization.
      -> 9) Thread Synchronization and Its Types
         ---------------------------------------
           Synchronization ensures that only one thread can access a shared resource at a time.
            Types:
            Synchronized Methods: Only one thread can execute a synchronized method at a time.
            Synchronized Blocks: Only one thread can execute a block of code at a time.
      -> 10) Deadlock
         --------------
            Deadlock occurs when two or more threads wait indefinitely for each other's locks.
            Example: Thread 1 holds Lock A and waits for Lock B, while Thread 2 holds Lock B and waits for Lock A.
      -> 11) Daemon Thread
         -----------------
            Daemon threads are background threads that support non-daemon threads (e.g., garbage collection).
            They terminate automatically when all non-daemon threads finish execution.
      -> 12) Object Class Methods Related to Threads
          ------------------------------------------
            wait(): Makes the current thread wait until another thread calls notify() or notifyAll().
            notify(): Wakes up a single waiting thread.
            notifyAll(): Wakes up all waiting threads.
      -> 13) Java Program to Demonstrate Deadlock
         ----------------------------------------
               public class DeadlockExample {
                   public static void main(String[] args) {
                       final String resource1 = "Resource1";
                       final String resource2 = "Resource2";

                       // Thread 1 tries to lock resource1 then resource2
                       Thread thread1 = new Thread(() -> {
                           synchronized (resource1) {
                               System.out.println("Thread 1: Locked Resource 1");
                               try {
                                   Thread.sleep(100); // Introduce delay to ensure deadlock
                               } catch (InterruptedException e) {
                                   e.printStackTrace();
                               }
                               synchronized (resource2) {
                                   System.out.println("Thread 1: Locked Resource 2");
                               }
                           }
                       });

                       // Thread 2 tries to lock resource2 then resource1
                       Thread thread2 = new Thread(() -> {
                           synchronized (resource2) {
                               System.out.println("Thread 2: Locked Resource 2");
                               try {
                                   Thread.sleep(100); // Introduce delay to ensure deadlock
                               } catch (InterruptedException e) {
                                   e.printStackTrace();
                               }
                               synchronized (resource1) {
                                   System.out.println("Thread 2: Locked Resource 1");
                               }
                           }
                       });

                       thread1.start();
                       thread2.start();
                   }
               }
               Explanation:
               Thread 1 locks resource1 and waits for resource2.

               Thread 2 locks resource2 and waits for resource1.

               Both threads wait indefinitely, causing a deadlock.
   
   77) Explain Enumeration in Java
   ++++++++++++++++++++++++++++++++


   78) Why Marker Interface in java
   ++++++++++++++++++++++++++++++++++++
      -> An interface without any abstract method  or any field is Marker interface
      -> Marker interace provides metadata of the class to the JVM or other frameworks
      -> Metadata means - if class implements serilizable interface means JVM now know to convert character to byte 
                          @Override : 
      -> Eg: Cloneable, Serializable, EventListener, ...
      -> This marker interface is upto Java 1.5 v  to provide metadata of the class 
      -> but they again simplify using annotations and reflection api to provide metadata of the class

      Approach               How It Provides Metadata
      ------------------------------------------------
      Marker Interface    :  Tags a class for special behavior (e.g., Serializable)
      Annotations         :  Provides rich metadata with flexibility (e.g., @Override, @Deprecated)
      Reflection API      :  Reads metadata at runtime for dynamic behavior
 
   79) What is Variable Arguments In Java
   +++++++++++++++++++++++++++++++++++++++
      -> This feature is introduce in java 1.5 to take multiple variable as parameter at one time by the java method 
      -> To declare variable arguments we need pass the parameter as dataType then ... ( 3 dots ) and variable name 
      -> Rules for Var arguments   :  some rules for var args that we must follow, otherwise, the code can't compile, 
            1) There can be only one variable argument in the method 
            2) Variable arguments (var args) must be the last argument 
            3) Variable argument should have only three ellipses (...) 
      -> method(Integer... numbers)
   
   80) What is difference between Query Parameter and Path Parameter
   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     -> GET request will not contain Request Body so we have to use either Query Param or Path Param to send data to server.
     -> Query Parameter : 
                         -> If we send multiple values on server through get request then we use this
                         -> data is in key and value format 
                         -> RequestParam annotation used to mapped property into method parameter 
                         -> url data seperated by & and starts with ?
                         -> Query Params should present only at end of the URL  : IMP
                         -> Ex : URL : http://localhost:8080/user?userid=202
     -> Path Parameter :
                         -> If we send single values on server through get request then we use this
                         -> Path Param will represent data directley
                         -> Path Params can present anywhere in the URL
                         -> Path Param will start with '/' and will be seperated by '/'
                         -> We need to represent Path Parameters position in the URL pattern like below
                              Ex:  @GetMapping("/user/{id}/data")
                         -> To read Path Parameters we will use @PathVariable annotation
                         ->  @GetMapping("/user/{id}/data")
                              public User getUser(@PathVariable("id") Integer userId) {
                              User user = dataMap.get(userId);
                              return user;
                              }
                         -> URL : URL : http://localhost:8080/user/202/data
                         
  

  82) Why Object Oriented Programming java , why not you choose another programming language 
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     OOP -> Provide security to our data
         -> multiple instances we can create for the single class 
         -> support code reusabbility
         -> Supports features like Inheritence ,Encapsulation , Polymorphism , Abstraction

  83) Explain throw and throws with example 
    +++++++++++++++++++++++++++++++++++++++
    public class NoDataFoundException extends RuntimeException {
        public NoDataFoundException() {
        }
        public NoDataFoundException(String msg) {
            super(msg);
         }
       }

        public class Demo {
            private String getName(int id) {
                if (id == 100) {
                    return "Raju";
                } else if (id == 101) {
                    return "Rani";
                } else {
                    throw new NoDataFoundException("Invalid Id");
                }
            }

            public static void main(String[] args) {
                Demo d = new Demo();
                d.getName(200);
            }
          }
 84) Can we access private variables outside the class
  --------------------------------------------------------
   => No , but I can access private variables outside the class using reflection
        package in.ashokit;
        public class Student {

            private int age = 20;

            public void getAge() {
                System.out.println("Age : " + age);
            }
        }
        package in.ashokit;
        import java.lang.reflect.Field;
        public class Demo {
            public static void main(String[] args) throws Exception {

                // loading class into jvm
                Class clz = Class.forName("in.ashokit.Student");

                // creating object for the loaded class
                Object obj = clz.newInstance();

                // getting the filed whose name is age
                Field field = clz.getDeclaredField("age");

                // making variable accessible outside of the class
                field.setAccessible(true);

                // set value to field
                field.set(obj, 35);

                Student s = (Student) obj;
                s.getAge();
            }
        }
  84) Can we access private methods outside the method
  ++++++++++++++++++++++++++++++++++++++++++++++++++++
     yes , using reflection how 
     Student.java code is same
     
     package in.ashokit;
        import java.lang.reflect.Method;

        public class Demo {

            public static void main(String[] args) throws Exception {

                Class<?> clz = Class.forName("in.ashokit.Student");

                Method method = clz.getDeclaredMethod("getAge");

                Object obj = clz.newInstance();

                method.invoke(obj, null);    means call the method
            }
        }

  82) What are the annotations are used in Junit for testing 
     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 

  83) Why object is parent class for all the classes what if we remove the object class in java
     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
     -> In Object class , they define only those methods which are commonly used in every class that why they define in Parent class  ,i.e Object class 


  84)  How your project will be deployed
    -----------------------------------
    -> 1st we will create a jira ticket for pipeline creation
    -> And we are going to send a request for devops team with ticket id to create the pipeline
    -> Once the pipeline will be created then one of our developer team member who is working on the stroy will run that
       Job and will see the job is working successfully or not
    -> if Job executeing successfully then we will close that ticket ,and run the job again and again to do the deployment on daily basis
    -> IF the Job is not executing then we will see the console output , to what is the root cause of the application
    -> If the problem is from code side then we will fixed that problem and we will re-run the job
    -> If the problem is in the pipeline , then we will send to the devops team they will work on that problem and fix it  
    -> After that we will re-execute the same job to make sure the job is executing successfully


  85) Have you create pipline creation
    ++++++++++++++++++++++++++++++++
     -> yes , in my team for non production enviormnet  , developer will responsible to create the pipeline 
     -> but for production enviorment we have the seperate Devops team
     -> Note : service based company - devops team handle this
           product based company - developer will handle this

  
  81) Java Arrays
   ++++++++++++++

        1) Array Declaration             => dataType[] arrayName; // Recommended
        2) Array Creation                => int[] numbers = new int[5]; // Creates an array with 5 elements
        3) Array Length
        4) Array Index                   => int[] numbers = {10, 20, 30, 40, 50};
                                            System.out.println(numbers[0]); // Output: 10
                                            System.out.println(numbers[4]); // Output: 50
        5) Array Literal                 => int[] numbers = {10, 20, 30, 40, 50};
                                            String[] names = {"Alice", "Bob", "Charlie"};
                                            Here, array declaration and initialization are done in a single step without using the new keyword.
        6) ArrayIndexOutOfBoundsException => no array index available but we access that index then this exception
        7) What is difference between array creation with array literal and with new keyword
                Aspect             Array Literal                              Array Creation with new
                ----------------------------------------------------------------------------------------------
                Syntax             Compact and concise.                       Explicit and requires new keyword.
                Initialization     Must initialize                            Can be initialized later.
                Default Values     No default values                           Elements are initialized to defaults.
                Flexibility        Fixed values at declaration.                Allows runtime size and initialization.

  82) Java Strings MEthods
  +++++++++++++++++++++++++
                Method                        Description                                                      Example                              Output
                ===============================================================================================================================================
               length()                       Returns the length of the string.                                "Hello".length();                       5
                                              ------------------------------------------------------------------------------------------------------------------
               charAt(int index)              Returns the character at the specified index.                    "Hello".charAt(1);                     'e'
                                              ------------------------------------------------------------------------------------------------------------------
               substring(int beginIndex)      Extracts a substring from the given index to the end.            "Hello".substring(2);                  "llo"
                                              ------------------------------------------------------------------------------------------------------------------
               substring(int beginIndex, int endIndex)   Extracts a substring within the given range.          "Hello".substring(1, 4);               "ell"
                                              ------------------------------------------------------------------------------------------------------------------
               indexOf(String str)            Returns the index of the first occurrence of the given string .  "Hello".indexOf("l");                    2
                                              ------------------------------------------------------------------------------------------------------------------
               lastIndexOf(String str)        Returns the index of the last occurrence of the given string.    "Hello".lastIndexOf("l");                3
                                              ------------------------------------------------------------------------------------------------------------------
               contains(CharSequence s)       Checks if the string contains the given sequence.                "Hello".contains("ll");                 true
                                              ------------------------------------------------------------------------------------------------------------------
               startsWith(String prefix)      Checks if the string starts with the given prefix.               "Hello".startsWith("He");               true
                                              ------------------------------------------------------------------------------------------------------------------
               endsWith(String suffix)        Checks if the string ends with the given suffix.                 "Hello".endsWith("o");                  true
                                              ------------------------------------------------------------------------------------------------------------------
               toLowerCase()                  Converts all characters to lowercase.                            "Hello".toLowerCase();                 "hello"
                                              ------------------------------------------------------------------------------------------------------------------
               toUpperCase()                  Converts all characters to uppercase.                            "Hello".toUpperCase();                  "HELLO"
                                              ------------------------------------------------------------------------------------------------------------------
               trim()                         Removes leading and trailing spaces.                             " Hello ".trim();                       "Hello"
                                              ------------------------------------------------------------------------------------------------------------------
               replace(char oldChar, char newChar) Replaces all occurrences of a character.                    "Hello".replace('l', 'p');              "Heppo"
                                              ------------------------------------------------------------------------------------------------------------------
               replaceAll(String regex, String replacement) Replaces substrings matching the regex.            "Hello123".replaceAll("\\d", "*");      "Hello***"
                                              ------------------------------------------------------------------------------------------------------------------
               replaceFirst(String regex, String replacement)  Replaces the first match of the regex.          "Hello123".replaceFirst("\\d", "*");   "Hello*23"
                                              ------------------------------------------------------------------------------------------------------------------
               split(String regex)            Splits the string into an array based on the regex.              "Hello World".split(" ");          ["Hello", "World"]
                                              ------------------------------------------------------------------------------------------------------------------
               concat(String str)             Concatenates the given string.                                   "Hello".concat(" World");            "Hello World"
                                              ------------------------------------------------------------------------------------------------------------------
               matches(String regex)          Checks if the string matches the regex pattern.                  "12345".matches("\\d+");                 true
                                              ------------------------------------------------------------------------------------------------------------------
               equals(String anotherString)   Compares two strings for equality.                               "Hello".equals("hello");                false
                                              ------------------------------------------------------------------------------------------------------------------
               equalsIgnoreCase(String anotherString) Compares two strings, ignoring case.                     "Hello".equalsIgnoreCase("hello");      true
                                              ------------------------------------------------------------------------------------------------------------------
               isEmpty()                      Checks if the string is empty ("").                               "".isEmpty();                          true
                                              ------------------------------------------------------------------------------------------------------------------
               isBlank() (Java 11)           Checks if the string is empty or contains only whitespace.         " ".isBlank();                         true
                                              ------------------------------------------------------------------------------------------------------------------
               join(CharSequence delimiter, CharSequence... elements)   Joins multiple strings with a delimiter.  String.join("-", "Java", "String"); "Java-String"
                                             ------------------------------------------------------------------------------------------------------------------
               repeat(int count) (Java 11)    Repeats the string n times.                                       "Hi ".repeat(3);                     "Hi Hi Hi "
                                              ------------------------------------------------------------------------------------------------------------------
               format(String format, Object... args)  Formats the string with placeholders.                      String.format("Age: %d", 25);        "Age: 25"
                                              ------------------------------------------------------------------------------------------------------------------
               compareTo(String anotherString)  Compares two strings lexicographically.                         "apple".compareTo("banana");          < 0
                                              ------------------------------------------------------------------------------------------------------------------
               compareToIgnoreCase(String anotherString) Compares two strings ignoring case.                    "Apple".compareToIgnoreCase("apple");   0
                                              ------------------------------------------------------------------------------------------------------------------
               getBytes()                     Converts the string into a byte array.                            "Hello".getBytes();          [72, 101, 108, 108, 111]
                                              ------------------------------------------------------------------------------------------------------------------
               toCharArray()                  Converts the string into a character array.                       "Hello".toCharArray();         ['H', 'e', 'l', 'l', 'o']
                                              ------------------------------------------------------------------------------------------------------------------
               strip() (Java 11)              Removes leading and trailing spaces (handles Unicode spaces).     " Hello ".strip();                 "Hello"
                                              ------------------------------------------------------------------------------------------------------------------
               stripLeading() (Java 11)       Removes only leading spaces.                                      " Hello ".stripLeading();          "Hello "
                                              ------------------------------------------------------------------------------------------------------------------
               stripTrailing() (Java 11)      Removes only trailing spaces.                                     " Hello ".stripTrailing();         " Hello"
                                              ------------------------------------------------------------------------------------------------------------------
               indent(int n) (Java 12)        Adjusts indentation by adding/removing spaces.                    "Hello".indent(2);                 " Hello"
                                             ------------------------------------------------------------------------------------------------------------------
               translateEscapes() (Java 15)   Converts escape sequences into characters.                        "\\nHello".translateEscapes();      "\nHello"
                                             ------------------------------------------------------------------------------------------------------------------

   83) String buffer methods    thread-safe due to synchronized methods.  |  Use StringBuilder instead of StringBuffer if thread safety is not required, 
       ++++++++++++++++++++                                                                                                  as StringBuilder is faster.
             Method                            Description                                                       Example                               Output
             ==================================================================================================================================================
            append(String s)                   Appends the specified string to the buffer.               sb.append("World");                        "HelloWorld"
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            insert(int offset, String s)       Inserts the given string at the specified index.          sb.insert(5, "Java");                      "HelloJavaWorld"
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            delete(int start, int end)         Deletes characters between the given indices.             sb.delete(5, 9);                           "HelloWorld"
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            deleteCharAt(int index)            Deletes a single character at the specified index.        sb.deleteCharAt(5);                        "Helloorld"
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            reverse()                          Reverses the sequence of characters in the buffer.        sb.reverse();                              "dlroWolleH"
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            setCharAt(int index, char ch)      Sets a character at the specified index.                  sb.setCharAt(0, 'J');                      "JelloWorld"
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            capacity()                         Returns the current capacity of the buffer.               sb.capacity();                            16 (default) or more
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            ensureCapacity(int minCapacity)    Ensures the buffer has at least the given capacity.       sb.ensureCapacity(50);                 Capacity increased if needed
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            setLength(int newLength)           Changes the length of the buffer (truncates or pads with \0).  sb.setLength(5);                       "Hello"
            -----------------------------------------------------------------------------------------------------------------------------------------------------
            

    84) String Builder methods      use when thread-safety not requored, unlike StringBuffer, but is faster for single-threaded applications.
       +++++++++++++++++++++++++    default capacity is 16 characters, but it grows dynamically.
         -> 

    85) Arrays Methods
        ++++++++++++++
           Method                                            Description                                 Example                              Output
           =============================================================================================================================================
            toCharArray()                                  to convert string into char array
            ---------------------------------------------------------------------------------------------------------------------------------------------
            sort(int[] arr)                                Sorts the array in ascending order.        Arrays.sort(arr);                   [1, 2, 3, 4, 5]
            ---------------------------------------------------------------------------------------------------------------------------------------------
            sort(int[] arr, int fromIndex, int toIndex)    Sorts a specific range of the array.       Arrays.sort(arr, 1, 4);             Partial sort
            ---------------------------------------------------------------------------------------------------------------------------------------------
            binarySearch(int[] arr, int key)               Searches for the key using binary          Arrays.binarySearch(arr, 3);        Index of key
                                                           search (sorted array required).
            ---------------------------------------------------------------------------------------------------------------------------------------------
            copyOf(int[] original, int newLength)          Copies an array to a new array with        Arrays.copyOf(arr, 3);              New array with 3 elements
                                                           the specified length.
            ---------------------------------------------------------------------------------------------------------------------------------------------
            copyOfRange(int[] original, int from, int to)  Copies a range of the array into           Arrays.copyOfRange(arr, 1, 4);      Subset of array
                                                           a new arrry
            ---------------------------------------------------------------------------------------------------------------------------------------------
            fill(int[] arr, int val)                       Fills the entire array with the given value. Arrays.fill(arr, 7);              [7, 7, 7, 7]
            ---------------------------------------------------------------------------------------------------------------------------------------------
            fill(int[] arr, int fromIndex, int toIndex, int val)  Fills a specific range of the       Arrays.fill(arr, 1, 3, 5);          Partial fill
                                                           array with a value.
            ---------------------------------------------------------------------------------------------------------------------------------------------
            equals(int[] a, int[] b)                       Compares two arrays for equality.          Arrays.equals(arr1, arr2);          true/false
            ---------------------------------------------------------------------------------------------------------------------------------------------
            deepEquals(Object[] a, Object[] b)             Compares nested arrays                     Arrays.deepEquals(arr1, arr2);      true/false
                                                           (multi-dimensional arrays).
            ---------------------------------------------------------------------------------------------------------------------------------------------
            hashCode(int[] arr)                            Returns the hash code of an array.         Arrays.hashCode(arr);               Hash code value
            ---------------------------------------------------------------------------------------------------------------------------------------------
            deepHashCode(Object[] arr)                     Returns the deep hash code of a            Arrays.deepHashCode(arr);           Hash code
                                                           multi-dimensional array.
            ---------------------------------------------------------------------------------------------------------------------------------------------
            asList(T... a)                                 Converts an array into a List.             Arrays.asList(arr);                 List view of array
                                                           multi-dimensional array.
            ---------------------------------------------------------------------------------------------------------------------------------------------
            toString(int[] arr)                            Returns a string representation of the array.  Arrays.toString(arr);           "[1, 2, 3]"
            ---------------------------------------------------------------------------------------------------------------------------------------------
            deepToString(Object[] arr)                     Converts multi-dimensional arrays to a string.  Arrays.deepToString(arr);  "[ [1,2], [3,4] ]"
            ---------------------------------------------------------------------------------------------------------------------------------------------
            stream(int[] arr)                              Converts the array into a Stream.          Arrays.stream(arr);                Stream object
            ---------------------------------------------------------------------------------------------------------------------------------------------
            parallelSort(int[] arr)                        Sorts the array using parallel sorting     Arrays.parallelSort(arr);         Sorted array
                                                            (faster for large arrays).
            ---------------------------------------------------------------------------------------------------------------------------------------------
            setAll(int[] arr, IntUnaryOperator generator)  Sets all elements using a generator function.   Arrays.setAll(arr, i -> i * 2);  [0, 2, 4, 6]
            ---------------------------------------------------------------------------------------------------------------------------------------------
            spliterator(int[] arr)                         Creates a Spliterator for parallel processing.  Arrays.spliterator(arr);      Spliterator object
            ---------------------------------------------------------------------------------------------------------------------------------------------

   85) Wrapper classes methods
      ++++++++++++++++++++++++++
       

       
            Method                                   Description                              Example                                       Output
            =============================================================================================================================================
            valueOf(String s)                     Converts a string to a wrapper object.      Integer.valueOf("123")                        123
                                                  -------------------------------------------------------------------------------------------------------
            parseXxx(String s)                    Converts a string to a primitive value.     Integer.parseInt("123")                       123 (int)
                                                  -------------------------------------------------------------------------------------------------------
            toString()                            Converts the value to a string.             Integer.toString(123)                         "123"
                                                  -------------------------------------------------------------------------------------------------------
            xxxValue()                            Converts wrapper object to primitive.       int x = obj.intValue();                     Primitive value
                                                  -------------------------------------------------------------------------------------------------------
            compareTo(Xxx obj)                    Compares two wrapper objects.               a.compareTo(b);                              0, >0, or <0
                                                  -------------------------------------------------------------------------------------------------------
            compare(Xxx a, Xxx b)                 Compares two primitive values.              Integer.compare(10, 5);                         1
                                                  -------------------------------------------------------------------------------------------------------
            equals(Object obj)                    Compares two wrapper objects for equality.   a.equals(b);                                 true/false
                                                  -------------------------------------------------------------------------------------------------------
            hashCode()                            Returns the hash code of the object.        a.hashCode();                                 Hash value
                                                  -------------------------------------------------------------------------------------------------------
            max(Xxx a, Xxx b)                     Returns the maximum of two values.          Integer.max(5, 10);                               10
                                                  -------------------------------------------------------------------------------------------------------
            min(Xxx a, Xxx b)                     Returns the minimum of two values.          Integer.min(5, 10);                               5
                                                  -------------------------------------------------------------------------------------------------------
            sum(Xxx a, Xxx b)                     Returns the sum of two values.              Integer.sum(5, 10);                               15
                                                  -------------------------------------------------------------------------------------------------------
            reverseBytes(Xxx a)                   Reverses the bytes of a number.             Integer.reverseBytes(1);                      16777216
                                                  -------------------------------------------------------------------------------------------------------
            bitCount(int n)                       Returns the number of set bits in binary.   Integer.bitCount(5);                             2
                                                  -------------------------------------------------------------------------------------------------------
            rotateLeft(int n, int d)              Rotates bits to the left.                   Integer.rotateLeft(5, 1);                        10
                                                  -------------------------------------------------------------------------------------------------------
            rotateRight(int n, int d)             Rotates bits to the right.                  Integer.rotateRight(5, 1);                       2
                                                  -------------------------------------------------------------------------------------------------------
            signum(int n)                         Returns the sign (-1, 0, 1).                Integer.signum(-10);                            -1
                                                  -------------------------------------------------------------------------------------------------------
    
    87) Character Wrapper Methods (Character class)
    ++++++++++++++++++++++++++++++++++++++++++++++++
            Method                            Description                                     Example                  Output
            ====================================================================================================================
            isDigit(char ch)                  Checks if the character is a digit.           Character.isDigit('5')         true
                                              ----------------------------------------------------------------------------------
            isLetter(char ch)                 Checks if the character is a letter.          Character.isLetter('A')        true
                                              ----------------------------------------------------------------------------------
            isLowerCase(char ch)              Checks if the character is lowercase.         Character.isLowerCase('a')     true
                                              ----------------------------------------------------------------------------------
            isUpperCase(char ch)              Checks if the character is uppercase.         Character.isUpperCase('A')     true
                                              ----------------------------------------------------------------------------------
            toLowerCase(char ch)              Converts character to lowercase.              Character.toLowerCase('A')     'a'
                                              ----------------------------------------------------------------------------------
            toUpperCase(char ch)              Converts character to uppercase.              Character.toUpperCase('a')     'A'
                                              ----------------------------------------------------------------------------------




            Integer to string convert
            +++++++++++++++++++++++++
            integer i=10;
            1) String s = Integer.toString(i)
            2) String s = String.valueOf(i)

            String to Integer convert
            +++++++++++++++++++++++++
            String s= "2019"
            1) int i = Integer.parseInt(s)
            2) int i= Integer.valueOf(s)

            String to char convert
            ++++++++++++++++++++++
            String s ="Nilesh";
            1) char ch = s.charAt(o)
            2) char[] c = s.toCharArray()

            char array to string conversion
            +++++++++++++++++++++++++++++++++
            char[] c = {'n','i'}
            String s= String.valueOf(c)

   83) Stream API Methods and Usage 23 methods : imp are stream(), map,flatmap,forEach,filter,collect,distinct
      +++++++++++++++++++++++++++++
      ------------------------------------------------------------------------------------------------------------------------
      Category                          Method                                         Description Example
      ------------------------------------------------------------------------------------------------------------------------
     Stream Creation                stream()                          Creates a sequential stream from a collection.
                                                                      List<String> list = Arrays.asList("A", "B"); Stream<String> stream = list.stream();
                                    ---------------------------------------------------------------------------------------------------------------------
                                    parallelStream()                  Creates a parallel stream from a collection. 
                                                                      Stream<String> parallelStream = list.parallelStream();
                                    ---------------------------------------------------------------------------------------------------------------------
                                    Stream.of(...)                    Creates a stream from values. Stream<Integer> stream = Stream.of(1, 2, 3);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    Stream.iterate()                  Generates an infinite stream with a function.   Stream.iterate(0, n -> n + 2).limit(5);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    Stream.generate()                 Generates an infinite stream with a supplier.  
                                                                      Stream<Double> randomStream = Stream.generate(Math::random).limit(3);
                                    ---------------------------------------------------------------------------------------------------------------------
Filtering & Transformation          filter(Predicate<T>)              Filters elements based on a condition. stream.filter(n -> n % 2 == 0);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    map(Function<T, R>)               Transforms each element.   stream.map(String::toUpperCase);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    flatMap(Function<T, Stream<R>>)   Flattens nested structures.   listOfLists.stream().flatMap(List::stream);
                                    ---------------------------------------------------------------------------------------------------------------------
Sorting & Distinct Elements         sorted()                          Sorts elements naturally.  stream.sorted();
                                    ---------------------------------------------------------------------------------------------------------------------
                                    sorted(Comparator<T>)             Sorts using a custom comparator. stream.sorted(Comparator.reverseOrder());
                                    ---------------------------------------------------------------------------------------------------------------------
                                    distinct()                        Removes duplicate elements.   stream.distinct();
                                    ---------------------------------------------------------------------------------------------------------------------
Reduction & Aggregation             reduce(BinaryOperator<T>)         Reduces elements to a single result.   stream.reduce((a, b) -> a + b);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    reduce(T identity, BinaryOperator<T>)  Reduces with an identity value.  stream.reduce(0, Integer::sum);
                                    ---------------------------------------------------------------------------------------------------------------------
Collecting Results                  collect(Collector<T, A, R>)       Collects elements into a collection.   stream.collect(Collectors.toList());
                                    ---------------------------------------------------------------------------------------------------------------------
Matching & Finding                  anyMatch(Predicate<T>)            Returns true if any element matches.   stream.anyMatch(n -> n % 2 == 0);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    allMatch(Predicate<T>)            Returns true if all elements match. stream.allMatch(n -> n % 2 == 0);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    noneMatch(Predicate<T>)           Returns true if no elements match.  stream.noneMatch(n -> n < 0);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    findFirst()                       Retrieves the first element.  stream.findFirst();
                                    ---------------------------------------------------------------------------------------------------------------------
                                    findAny()                         Retrieves any element.  stream.findAny()
                                    ---------------------------------------------------------------------------------------------------------------------
Counting & Statistics               count()                           Counts the number of elements.   stream.count();
                                    ---------------------------------------------------------------------------------------------------------------------
                                    max(Comparator<T>)                Finds the maximum element. stream.max(Integer::compareTo);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    min(Comparator<T>)                Finds the minimum element. stream.min(Integer::compareTo);
                                    ---------------------------------------------------------------------------------------------------------------------
Iteration & Debugging               forEach(Consumer<T>)              Iterates over each element.   stream.forEach(System.out::println);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    peek(Consumer<T>)                 Intermediate operation for debugging.  stream.peek(System.out::println);
                                    ---------------------------------------------------------------------------------------------------------------------
Skipping & Limiting                 limit(long n)                     Limits the number of elements.   stream.limit(3);
                                    ---------------------------------------------------------------------------------------------------------------------
                                    skip(long n)                      Skips the first n elements.   stream.skip(3);
                                    ---------------------------------------------------------------------------------------------------------------------
Parallel Processing                 parallelStream()                  Enables parallel stream processing. list.parallelStream().sorted();
                                    ---------------------------------------------------------------------------------------------------------------------

   Collectors methods in stream api 
   ++++++++++++++++++++++++++++++++
   => Collectors class in Java provides various methods for collecting and processing stream elements into different data structures
     like List, Set, Map, and performing grouping, partitioning, summarization, and more.

         Method                                 Description                              Example
         ========================================================================================
      Collectors.toList()                      Collects elements into a List.                List<String> list = stream.collect(Collectors.toList());
                                               ---------------------------------------------------------------------------------------------------------------------
      Collectors.toSet()                       Collects elements into a Set                  Set<Integer> set = stream.collect(Collectors.toSet());
                                               (removes duplicates).
                                               ---------------------------------------------------------------------------------------------------------------------
      Collectors.toCollection(Supplier<C>)     Collects elements into a custom collection.   Deque<String> deque = stream.collect(Collectors.toCollection(
                                                                                             ArrayDeque::new));
                                               ---------------------------------------------------------------------------------------------------------------------
      Collectors.toMap(keyMapper, valueMapper) Collects elements into a Map<K, V>.           Map<Integer, String> map = stream.collect(Collectors.toMap(
                                                                                             String::length, Function.identity()));
                                               ---------------------------------------------------------------------------------------------------------------------
      Collectors.toMap(keyMapper                Handles duplicate keys                       Map<Integer, String> map = stream.collect(Collectors.toMap(
          , valueMapper, mergeFunction)         by specifying a merge function              .String::length, Function.identity(), (e1, e2) -> e1));
                                               ---------------------------------------------------------------------------------------------------------------------
      Collectors.toMap(keyMapper                Collects elements into a                     Map<Integer, String> map = stream.collect(Collectors.toMap(  
       , valueMapper, mergeFunction, mapSupplier) custom Map implementation.                 String::length, Function.identity(), (e1, e2) -> e1, 
                                                                                             LinkedHashMap::new));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.groupingBy(classifier)         Groups elements into a                       Map<Integer, List<String>> map = stream.collect(
                                                Map based on a classifier function.          Collectors.groupingBy(String::length));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.groupingBy(classifier, Collector) Groups elements and                       Map<Integer, Set<String>> map = stream.collect(
                                                   applies a downstream collector.           Collectors.groupingBy(String::length, Collectors.toSet()));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.groupingBy(classifier, supplier, Collector)   Groups elements into          Map<Integer, LinkedList<String>> map = 
                                                            a custom map implementation.     stream.collect(Collectors.groupingBy(String::length, 
                                                                                             LinkedHashMap::new, Collectors.toCollection(LinkedList::new)));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.partitioningBy(Predicate<T>)   Partitions elements into a                   Map<Boolean, List<Integer>> map = stream.collect(
                                                Map<Boolean, List<T>> based on a predicate.  Collectors.partitioningBy(n -> n % 2 == 0));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.partitioningBy(Predicate<T>, Collector<T, A, R>) Partitions elements        Map<Boolean, Set<Integer>> map = stream.collect(
                                                   and applies a downstream collector.       Collectors.partitioningBy(n -> n % 2 == 0, Collectors.toSet()));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.counting()                     Counts the number of elements.               long count = stream.collect(Collectors.counting());
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.summingInt(ToIntFunction<T>)   Computes the sum of extracted integer values.   int sum = stream.collect(Collectors.summingInt(
                                                                                                                                      String::length));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.summingDouble(ToDoubleFunction<T>)  Computes the sum of extracted double values. double sum = stream.collect(Collectors.summingDouble(
                                                                                                                               Employee::getSalary));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.summingLong(ToLongFunction<T>) Computes the sum of extracted long values.   long sum = stream.collect(Collectors.summingLong(
                                                                                                                          Employee::getSalary));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.averagingInt(ToIntFunction<T>) Computes the average of extracted integer values.  double avg = stream.collect(Collectors.averagingInt(
                                                                                                                           String::length));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.averagingDouble(ToDoubleFunction<T>) Computes the average of extracted double values.   double avg = stream.collect(
                                                                                                       Collectors.averagingDouble(Employee::getSalary));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.averagingLong(ToLongFunction<T>)  Computes the average of extracted long values.  double avg = stream.collect(Collectors.averagingLong(
                                                                                                                              Employee::getSalary));
                                                ---------------------------------------------------------------------------------------------------------------------
      Collectors.summarizingInt(ToIntFunction<T>)  Computes summary statistics for extracted integer values.   IntSummaryStatistics stats = stream.collect(
                                                                                                              Collectors.summarizingInt(String::length));
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.summarizingDouble(ToDoubleFunction<T>)  Computes summary statistics for extracted double values. DoubleSummaryStatistics stats = 
                                                                                      stream.collect(Collectors.summarizingDouble(Employee::getSalary));
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.summarizingLong(ToLongFunction<T>)   Computes summary statistics for extracted long values.   LongSummaryStatistics stats = stream.collect(
                                                                                                          Collectors.summarizingLong(Employee::getSalary));
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.joining()                      Joins elements into a single string.                String result = stream.collect(Collectors.joining());
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.joining(delimiter)             Joins elements with a delimiter.                    String result = stream.collect(Collectors.joining(", "));
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.joining(delimiter, prefix, suffix) Joins elements with a delimiter, prefix, and suffix.  String result = stream.collect(Collectors.joining(", ", "[", 
                                                                                                                                                           "]"));
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.reducing(BinaryOperator<T>)   Reduces elements using a binary operator.            Optional<String> result = stream.collect(Collectors.reducing((s1, s2)
                                                                                                                                                  -> s1 + s2));
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.reducing(T identity, BinaryOperator<T>) Reduces elements with an identity value.     String result = stream.collect(Collectors.reducing("", (s1, s2) -> s1 
                                                                                                                                                     + s2));
                                                 ---------------------------------------------------------------------------------------------------------------------
      Collectors.reducing(U identity, Function<T, U> mapper, BinaryOperator<U>)  Reduces elements with mapping and an identity value.  int totalLength = stream.collect(
                                                                                                              Collectors.reducing(0, String::length, Integer::sum));
                                                 ---------------------------------------------------------------------------------------------------------------------



   84) What is difference between stream().min() // max() and Collectors.minBy() //maxBy() method
    ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       stream.min() | stream.max()  and maxBy()| minBy()  both gives same results 
       but some basic difference is 

      Collection.minBy() -> input parameter uses comparator to give min and max value and it also return the data as optional other wise NullPointerException



