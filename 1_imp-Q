       Introduction
        ------------
         ->  Hi , My name is Nilesh , I am a B.Tech graduate , and currently I am working in Infogain India private limited as Java Developer
         ->  And Total I have 2.10 years of Experience as Java Developer and In this period of Time , I got the oppertunity to work with several java based technologies 
             like Java , J2EE, Spring , SPring Boot , REst Api's , Microservices , Oracle DataBase and Several
             tools like  Git , Maven , SonarQube , Junit etc
         -> Talking about my project , Currently I working on IES application 
            We are developing this application for Rhode Island Goverment 
            and with the help of this application we are providing health and insurance plans  for the RI state citizens 
            We are providing 
            -> SNAP 
             -> CCAP
             -> Medicaid
             -> Medicare
             -> QHP and
             -> RIW
           ANd if citizens wants to apply for this plan then they need to visit to the nearest DHS department , where the Caseworkers are working who are going to apply
           plan for the citizen because our app is interanet app
           Caseworker use this IES , they collect the data from the citizen and determine the citizen is eligible for the plan or not 
           For every plan, conditions will be available  , if citizens data matching with those condition , citizen will be approved for the plan 
          -Then  he will get the benifit amount of paln on monthly basis

           ANd talking about my role in this IES , I am working on Caseworker module  , and through this module I am going to send the notices to the citizens email id
           if they successfully apply for the plan , and also if there plan is going  to expire we send those notices also 

           And I am also responsible to develop the rest api's by dividing the component classes into entity , services , controller , writing the test cases for the classes
           Handling the exception for the classes , sending api response , to client web

           ANd talking about my day to day activities 
              - daily we have scrum meting at 10 am 



        1) What is Java and Why Java
        +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        Java:
        - Java is programming language , platform and technology
        - Java is programming language because by using java we can write programs
        - platform means Any hardware or software environment in which a program runs,is known as a platform
        - JRE and API are called as platforms 
        - java is called as technology also because using java we can develop web applications , distribution applications , standalone applications
        - Java is a high level, robust, object-oriented and secure programming language.
        - developed by Sun Microsystems , where James Gosling is known as the father of Java.  
        Why Java:
        - Portability : it can run on any platform and open source
        - Security : it protects the customers from malicious script injection
        - Strong OOPS concept => Resuability , performance etc
        - Robust : Its reliable and efficeent  |  मजबूत: ते विश्वसनीय आणि कार्यक्षम आहे
        - Widely used : Simple programing language and easy to learn




       2)explain what are the S.O.L.I.D principles and Why should we use SOLID principles?
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       -> Every Software application is incomplete with out SOLID principles 
       -> Because they provide basic  fundamental guidelines to develop Object Oriented based software application . 
       -> With the help of this guidelines we can make the application code easily  understandable , scaleable , reuseable , maintainable , and testable 
       -> S.O.L.I.D principles are use to avoids the bad designing of the software.
       -> SOLID is an acronym of five principles, each principle has it's own guidelines like they have

       -> Single Responsibility Principle (SRP)
       -> Open-Closed Principle (OCP)
       -> Liskov Substitution Principle (LSP) 
       -> Interface Segregation Principle (ISP)
       -> Dependency Inversion Principle (DIP)

       -> Single Responsibility Principle
       ++++++++++++++++++++++++++++++++++
         - According to this principle every Java class must have only single functionality. 
         - Because if we Implementation of multiple functionalities in a single class then the code mashup 
         - and if any modification we want required to do then it may affect the whole class. 
         - So , One class , one functionality code can be easily maintained by this principle .
         - Ex: class Student{
               calculatePercentage();
               addStudent();
               printDetails();

               } 
         - Insted of writing all methods in one class , create seprate class for each method

         -> Open-Closed Principle
         +++++++++++++++++++++++++++
         - According to this principle the class should be open for extension but closed for modification.
         - extension means class allows us to implement new functionality  
         - closed for modification means class cannot allow to modify to avoid the functionality disturbance of same class

         -> Liskov Substitution Principle (LSP) this is related to inheritance
         ++++++++++++++++++++++++++++++++++++++
         - According to this principle  child classes must be completely substitutable for their parent classes.
         - ex: father is Engineer and son is Teacher and they both are from same family , In this we can't replace 
           father 

         -> Interface Segregation Principle
         ++++++++++++++++++++++++++++++++++
         -  According to the principle larger interfaces split into smaller ones.
         -  Because the implementation classes use only the methods that are required. 
         -  We should not force the client to use the methods that they do not want to use.
         -  The goal of the interface segregation principle is similar to the single responsibility principle. 
        
         ->Dependency Inversion Principle
         ++++++++++++++++++++++++++++++
         -  According to the principle we must use abstract classes and interfaces instead of concrete implementations.
         -  High-level modules should not depend on the low-level module but both should depend on the abstraction.
         -  Ex: Dependency Injection for loose coupling




         3) What are the Design patterns you used in your project (ABCCDSS FMM)
         ++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         => Desing patterns means proven solution of common problems while developing the software applications
         => Yes , I work on design patterns , I dont create any design patten from my sode but yes I have hands on experience on internal Design patterns 

         1) Singleton Design Pattern
         2) Factory Design Pattern
         3) Builder Design Pattern
         4) Microservices Design Pattern
         5) Circuit Breaker Design Pattern
         6) API gateway Design Pattern
         7) MVC Design Pattern
         8) Cache Design Pattern
         9) Strategy Design Pattern
         10) DAO design Pattern
         
             1) Singleton Design Pattern
             +++++++++++++++++++++++++++
             -> Every Spring bean is by default singleton
             -> We no need to maintain Bean Scope
             -> The default scope of the spring bean is Singleton
             -> Every Controller, every Repository , Every Spring Bean Class is by default considered as a Singleton

             2) Factory Design Pattern
             +++++++++++++++++++++++++
             -> IOC container is going to use this Factory Design Pattern to create the Bean Objects 

             3) Builder Design Pattern
             +++++++++++++++++++++++++
             -> We are creating web client object  or Rest Templete object or swagger beans object those are called as builder design patterns

             4) Microservices Design Pattern
             +++++++++++++++++++++++++++++++
             -> Insted of developing all the functionalities in single project , 
             -> We are dividing the functionalities into microservices
             
             5) Circuit Breaker Design Pattern
             +++++++++++++++++++++++++++++++++
             -> When any failure occurs in our microservice , insted of giving the error we can executing the fall back logic by using this circuit breaker.
             -> It is used to implement Falt tollerance system in our application

             6) API gateway Design Pattern
             +++++++++++++++++++++++++++++
             -> TO manage all the Backend api's at one place by using Routing and Filtering  we are using API gateway design pattern 

             7) MVC Design Pattern
             ++++++++++++++++++++++
             -> Model-View-Controller (MVC) Pattern is one of the architectural patterns for creating web applications with loosely couplling

             8) Cache Design Pattern
             ++++++++++++++++++++++++++++++
             -> Cache Design Pattern we are using in our application by using Radis Cache
             -> It is used to implement the performance of the application
             -> Insted of getting data from the database every time we can store the data into the cache ad we can take the cache data to use in our application

             9) Strategy Design Pattern 
             ++++++++++++++++++++++++++++
             -> Strategy Design Pattern  is nothing but we are following the rules to develop our application with Interfaces 
             -> We are not using Inheritence to reuse the functionality of one class in the another class 
             -> We are using Interfaces to communicate  from one class to another class , that comes under Strategy Design Pattern 
 
             10) DAO design Pattern
             +++++++++++++++++++++
             -> Data Access Object  pattern
             -> when we design classes that communicate with databases.
             -> Then we seperate Service layer data and entiy layer data 

      4) What are the OOP principles
      +++++++++++++++++++++++++++++++++
      -> OOP is one type of programming which is based on classes and object insted of functions 
      -> Class  : class is one programming template and programming template consist of data and logic and that data and logic we are going to implement 
                  according to our requirement
      -> Object : Object is the instance of the class , it is  like a real time world existing things and It consists of 3 main characteristics Identity , properties and Functionalities
                  Identity: means to differentiate one object from another object
                  properties: means to hold the data for ex: like accNo, accHolderName , pin   
                  functionalities : is for doing some operation on properties like withdraw() , balanceEnquiry() , deposit()
      -> And it has 4 main principles i.e : Inheritance , Abstraction , Encapsulation , and Polymorphism
                                  
      1)Inheritance  : Inheritance means creating the new class form the existing class , so we can reuse the super class functionalities in sub class ,
                       and also we can create the new functionalities in sub class
                       here the parent class is called as super class and child class is called as sub class .
                       By using extends keyword we achive the inheritance in class and by using implements keyword we achive inheritence in interface
                       and in java types of Inheritance are
                       Single Inheritance : only one one super and sub class
                       Mutilevel Inheritance : having multiple sub classes 
                       Multiple inheritance : achive by using Interaface : super class reuse multiple times

      2) Abstraction : The process of hiding the internal implementation from the user and provide only the services those we are offering is Abstraction
                       We can achive the abstraction by using Abstract class and Interface  
                       Generally we use Interface : All methods in interface by default public and abstract
                                                    and variables public , static and final
                                                    form java 8 we can add default and static methods in interface

      3) Encapsulation :-> The process of Wrapping the data and code into the single unit is called Encapsulation 
                        -> In java encapsulation is achieved by declaring the instance variables of a class as private,so they can only accessed within the class.
                        -> ANd to access the variables outside , public methods called getters and setters which are used to retrieve and modify the values
                           of the instance variables
                        -> data hiding and abstraction we can achive 
                        -> private = for data hiding

      4) Polymorphism : -> When two classes have IS-A relation and One object refer both super class and sub class members then this is called as Polymorphism 
                        -> means one object have abality to take many forms 
                        -> One interface having multiple implementation classes is polymorphism example
                        -> Compile-Time Polymorphism: Achieved through method overloading (same method name with different parameters).
                        -> Runtime Polymorphism: Achieved through method overriding (subclass redefines a method of the superclass).

      5) What is difference between class and Interface
      +++++++++++++++++++++++++++++++++++++++++++++++++
      Class
      ----
         -> class keyword used to create.
         -> A class can be instantiated i.e., objects of a class can be created.
         -> Classes do not support multiple inheritance.
         -> It can be inherited from another class by using the keyword ‘extends’. 
         -> It can contain constructors.
         -> It cannot contain abstract methods.
         -> Variables and methods in a class can be declared using any access specifier(public, private, default, protected).
         -> Variables in a class can be static, final, or neither.

      Interface
      ---------
         -> interface keyword used to create an interface .
         -> An Interface cannot be instantiated i.e. objects cannot be created.
         -> The interface supports multiple inheritance.
         -> It cannot inherit a class by using the keyword ‘implements’ and it can be inherited by an interface using the keyword ‘extends’.
         -> It cannot contain constructors.
         -> It contains abstract methods only.
         -> All variables and methods in an interface are declared as public.
         -> All variables are static and final.


      6) What are your roles and responsiblities in your project  -> in Development and in Bach Programming
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      - My roles and responsibilities in IES application is 
      - first of all what ever the responsibilities that I get I analysis that requirement  then I go for design and development
      - I design the Component classes with the help of MVC design pattern and also I am responsibile for developning the persistence layer with the 
         help of spring Data JPA 
      - After developing the services , controller , entity classes I perform the code review with the help of SonarQube framework
      - I also involve in the unit Testing and Integeration testing 
      - Also I am going to support the SIT and UAT phases for if any code defect is there then for that defect fixing
      - On daily basis my responsibility is to send the notices to citizens email id for that we create one batch job 

       //- Basically we are developing the application i.e IES application , and this application we are developing 
        by using Agile technology
        - and what ever the requirement I get I analysis that requirement then I will do design and development 
        - I develop Component classes using MVC design patterns
        - I am also responsible to develop Persistence layer using JPA framework
        - On daliy basis I created the batch jobs to process the citizens notices 
        - I involve in the code review using Sonar Qube framework
        - I also invloved in the unit testing and integration testing
        - I support SIT and UAT phases for the defects fixing  
        - This are my roles and responsiblities in my project //

       7) What kind of work you are doing right now in your project
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       -> Currently I am supporting to the frontend team to build the RI state national pregency related helth camp UI
          with the help of html , css, reactJs component
       -> Right now I am working on the RI state National Pregrency related health camp 
          that UI I am developning uisng HTML CSS and ReactJS Component

       8) What are your day to day activities in the Project
       +++++++++++++++++++++++++++++++++++++++++++++++++++++++
       In my day to day activities basically my day starts with 
        => My daily work start from 10 o clock am  , I login at 10 o clock 
        => and My scrum meeting is at 11 o clock
        1) On daily basis we have stand up calls which are arrange by our scrum master
           => where I expalain my yesterday and todays task status
           => What I have done yesterday and what today I am doing 
           => If any challenge I face at last I disucss 
           => or If the task is complete then the new task is allocated by the scrum master through JIRA or I will allocte that that for me 
        2) Also every day I have the eyes on the emails and messages on the teams apps 
           => any one is asking on any challenging work if they face on teams group channel 
           => Any meeting on calender
        3) If I face any challenge then I schedule a one to one call on teams  and discuss about that chellange
        4) Also daily I check the code update on git and perform the git operation accoirding to requirement

      9) How the task Is allocate for you 
      +++++++++++++++++++++++++++++++++++++++
       => On Jira the task are allocate for us 
       => If task is in To Do status then I allocate it on my name 
       => I confirm the status on jira as In Progress  
       => after the task is done then I review the code , perform Unit Testing
       => And after that I give the task status as ready to Test on Jire 
       => If any bug is issue form testing team I will solve that 
       => After the sit team gives Done status 
       => I will Save the status as Done for the task  

      10) What are the challenges you haved faced in your project
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> In our Application there is one Corresponding module is there , which sends the notices to the citizens email with plan details
         , when citizen successfuly apply for the plan
      -> Initial days this modules works properly as expected , but after few days , more traffic comes, and citizens have complaints that 
          they dont get notices on there email id 
      -> not getting notice on there email means citizens dont know they successfully apply for the plan or not .
      -> So this is one big issue that we face in our application.
          So how do you resolve that 
          --------------------------
      -> Actually we understand  , Before getting the issue whatever the logic we build to send the notices to citizens emails ,
          that send the notices one by one , means that module capacity is 3600 notices per hour 
      -> After identifying the issue we done some research and development and we implemented Multithreading in the project.
      -> we realize that notices are indipendent , one notice does not have relation ship with other notice , because every citizen 
           will have there own indivisual notice 
      -> So insted of executing notice generation logic with 1 thread , we have implemented multithreading in our project by using Executer services

      
	  11) Different Enviorments of one project
	  +++++++++++++++++++++++++++++++++++++++++
	  - In my project , total 5 Enviorment are there 

            1) Dev Env : Developers will use it for code Integration testing

            2) SIT Env : Testers will use it application end to end testing
                         ( System Integration testing also called as QA Enviorment )
            3) UAT Env : Client / Client Side Team will use it for acceptance testing.
                         ( User Acceptance Testing )
                           Note: In UAT client / client side team will decide GO or NO-GO
                              GO : Approved for Production deployment
                              NO-GO : Denied for Production Deployment
            4) PILOT Env : Pre-Prod Env for testing and they application with  live data
            5) PROD Env  : Live Environment (endusers will access from prod app) 
		
	  12) How many repository are available for your project
	  ++++++++++++++++++++++++++++++++++++++++++++++++++++++
	  - In my project repository is only one but branches are different
            - main / master(default) 
            - develop
            - feature
            - sit
            - uat
            - release .... like this 
        - Why this much brances - for parallel production

	  13) What are the annotations you know and you use in your application SIBEERRRRIA-PCCC(Siberia-PC)
	  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   	  1) SpringBootApplication :  This annotation is used with start class of the spring boot application
                                    This annotation is equals to 3 annotations @SpringBootConfiguration, @EnableAutoConfiguratio, @ComponentScan
                                    Without this annotation we cannot start our application
   	  2) ComponentScan  : to scan all base packages
   	  3) Entity         : To declare the class as Entity class ,so that class will communicate with data base
        4) Id             : To generate primary key value
        5) Service        : TO declare the class as Java Bean class , so IOC container manage the object
        6) RestController : To declare the class as Distributed class ,so it can handle the request response
        7) Component      : TO declare the class as Java Bean class , so IOC container manage the object
        8) Configuration  : If we want to create custom bean object for our method then that class must be declared with @Configuration annotation
        9) RequestBody    : SO method can take input as a form body
        10) RequestPath   : to take multiple variables as input from the URL path
        11) PathVariable  : To take input as parameter from the URL path
        12) RestControllerAdvice : TO handle the class as Global Exceptional Handler
        13) ExceptionHanlder : To declare the method as exception hanlder
        14) Bean          : If we want to create custom bean for our method then we use this annotation
        15) Autowired     : To perform dependency injection

		14) Explain your project architecture and its flow 
      ++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> IES application have total 26 modules , few of the modules I know 
      -> like  - Admin Module
               - Case Worker Module
               - Regestration Module
               - Data Collection Module
               - Eligibility Determination Module
               - Correspondence Module 
               - Batch Module
               - Benefits Issue Module
               - Reports Module
      -> Admin Module
         ++++++++++++
         -> Admin api responsibility is to Activate and DiActivate the accounts for the Caseworkers .
         -> and another responsibility of the Admin module is the Manage the Plans like
             -> Plan start date
             -> Plan end date
             -> Which plan is to activate this year
             -> Which plan is to diactivate this year
             Note Caseworkers cannot create account directly 
      ->Caseworker Module
        +++++++++++++++++
        -> This CaseWorkers api is operated by the Caseworkers to apply the plan for the citizens
        -> In Caseworker 
             - Caseworker Login
             - Edit Profile for Caseworker
             - Forgot Password for Caseworker
             - Regestration for citizen
             - How many Citizens REgister
             - How many citizens form is approved
             - How many citizens form is denied
      -> Application Regestration Module
        +++++++++++++++++++++++++++++++
        -> In this api the Caseworker can apply the plans to the citizens 
        -> Application Regestration api will collect citizen basic information and it will verify citizen belongs to RI state or not .
        -> Application Regestration api verify the citizen is from RI state goverment or not through SSA-WEB API 
        -> This SSN-WEB API is 3rd party api ( central goverment project )
        -> If citizen belongs to RI state then only Application Regestration api citizen to apply for the paln
        -> If citizen not belongs to RI state then Application will not created for citizen to apply for the paln
      -> Data Collection Module
       ++++++++++++++++++++++
        -> Data Collection api is responsible to collect the citizen data which is required to apply for the plan
        -> Citizens Data like
            1) Family details 
            2) Education details
            3) Employed details
            4) Income details
            5) Kids details etc
            Note : From UI screens we collect the data for this 
      -> Eligibility Determination
       +++++++++++++++++++++++++
          -> Eligibility Determination api is responsible to verify citizen data is eligible for the plan or not
          ->for  Different palans have different Eligibility criteria 
          -> If citizen data matches with plan criteria then citizen will be aprroved for the paln otherwise citizen plan will be denied 
          Note : Approved citizen will get benefits amount from the Govt.
      -> Correspondence Module
       +++++++++++++++++++++
          -> Correspondence Module api is responsible to send Notices( means PDF notice ) to citizens regarding their elegibility
          -> Notices like
              - Approved Notice
              - Denied Notice 
              - Termination Notice  if you terminated 
              - Plan renewal Remainder Notice , 15 , 30 , 60 days  remainder
              - Missing Documents Notice- birth certificate missig
          -> Notice nothing but one PDF document 
              - Hi congrulations , you apply for SNAP paln 
              - You got approved for this plan
              - your plan will start form this date  and end on this date 
              - monthly you are going to get this much amount 
              - Like that we generate one notice and send through PDF
           -> If application got denied that information also generate and send through PDF on mail
           -> remainder notices like your paln is comming to expire do you want to reniew that plan , for that come to DHS office and reniew that plan
      -> Benefits Issue Module
      +++++++++++++++++++++
         -> This api is responsible to send benefits amount to approved citizens
      -> Reports Module
       +++++++++++++++
          -> Reports api  is used to generate reports in excel/pdf format with application data 
             - Report Based on Plan Name
             - Report Based on Plan Status
             - Report Based on Duration (Start date and end date)
             - reports base on Citizen Gender 
          -> I want to get all the  people who applies for SNAP
          -> all data of Denied people 

		15) What is differece between Fail Safe and Fail Fast collections with example
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

        => Fail Fast Collections will throw error immediately when we modify collection object while traversing the collection.
           Ex: ArrayList , LinkList , HashSet , etc
           Fail Fast Collection will throw error ConcurrentModificationException when we modified

        => Fail Safe Collections will not throw any  error if we modify collection object data (Add / Remove) whilw traversing 
           Ex : CopyOnWriteArrayList  , ConcurrentHashMap  , IdentityHashMap  ,  etc....
      
      what is difference between map and flatmap in java 8
      +++++++++++++++++++++++++++++++++++++++++++++++++++++
      -> Both methods are available in Stream interface 
      -> Both methods are used for intermediate operations (means transforming one object form into another object form)
      -> map() method is only used for transformation of objet( one to one transformation ) ( one input one output)
      -> flatMap() is used for transformation and flatering (one to many transformation) ( one input multiple output)( ex : toList)

     16) Explain difference between String and StringBuffer and StringBuilder  
     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       
                                 String                              StringBuffer                          StringBuilder
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       1)Introduce             Java 1                                Java 1                                  Java 1.5
       ------------------------------------------------------------------------------------------------------------------------------------------
       2) Muatabilty           Immutable                              Mutable                                Mutable     
       ------------------------------------------------------------------------------------------------------------------------------------------
       3) Thread Safety        Thread Safe                           Thread Safe(multihtreading)             Not Thread Safe
       ------------------------------------------------------------------------------------------------------------------------------------------
       4) Performance wise     High(Async Synchronization)           Low(Due to Synchronization)             High(No-Synchronization)
       ------------------------------------------------------------------------------------------------------------------------------------------
       5) When to use          used when we want immutable string    used when Thread safety is required     used when Thread safety is not required
       ------------------------------------------------------------------------------------------------------------------------------------------
   
       immutable    : Not change any thing
       mutable      : can be change 
       Synchronize  : one thread at one time
       Asysnc       : multithread at one time
       Thread safe  : multithreading

      17) What is difference between Synchronous , Asynchronous and MultiThreading
       ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
          Sync -> one thread execution then next thread execute upto that the next thread is going to wait for the 1st thread execution
          Asunc-> at every request new thread is execute , not wait not any older thread to execute

       


      18) What id difference between Comparable and Comparator with example
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
            Feature                      Comparable                       Comparator
            ================================================================================================
            Package                      java.lang                        java.util
            -----------------------------------------------------------------------------------------------
            Method                       compareTo(Object obj)            compare(Object obj1, Object obj2)
            -----------------------------------------------------------------------------------------------
            Sorting Logic                Defined in the same class.       Defined in a separate class.
            -----------------------------------------------------------------------------------------------
            Flexibility                  Less flexible (single property). More flexible (multiple properties).
            -----------------------------------------------------------------------------------------------
            Use Case                     Natural/default sorting.         Custom sorting.
            -----------------------------------------------------------------------------------------------

      19)  What are the different ways to create new thred
       +++++++++++++++++++++++++++++++++++++++++++++++++
           Feature              Extending Thread                  Implementing Runnable                Implementing Callable
           ===================================================================================================================================
           Method               run()                             run()                                call()
           ----------------------------------------------------------------------------------------------------------------------------------
           Return Type          void                              void                                 Object (via Future)
           ----------------------------------------------------------------------------------------------------------------------------------
           Exception Handling   Limited                           Limited                              Better exception handling (throws)
           ----------------------------------------------------------------------------------------------------------------------------------
           Multiple Inheritance Not supported                     Supported                            Supported
           ----------------------------------------------------------------------------------------------------------------------------------
           Use Case             Simple thread creation           Separation of task and thread logic   Result-oriented or complex tasks
           ----------------------------------------------------------------------------------------------------------------------------------

      20) What is difference Runnable and Callable interface in java
      -------------------------------------------------------
      => Runnable Interface
         ------------------
         -> If we implement Runnable interface then we have to override run () method which will not return anything.
         -> And also we need to create thread object every time which is not recommended
         -> ex: public class Demo2 implements Runnable{
                @Override
                public void run() {
                    System.out.println("run()- method called");
                }
                public static void main(String[] args) {
                    Demo2 d1 = new Demo2();
                    Thread t1 = new Thread(d1);
                    t1.start();
                }
            }
      => Callable Interface
         ------------------
         -> Callable interface introduced in java 1.5v 
         -> Using callable interface we can implement multi threading
         -> We will use Executors framework in order to deal with Callable interface.
         
         -> Ex: public class Demo4 {
             public static void main(String[] args) {
                 Demo4 d = new Demo4();
                 d.processNotifications();
             }
             public void processNotifications() {
                 List<Orders> orders = dao.getOrders();
                   ExecutorService executorService = Executors.newFixedThreadPool(10);
                 for (int i = 1; i <= orders.size(); i++) {
                     executorService.submit(new Callable<Object>() {
                         @Override
                         public Object call() throws Exception {
                             sendNotification(orders.get(i));
                             return null;
                         }
                     });
                 }
             }
             public static void sendNotification(Order order) {
                 //get order details
                 // get customer details
                 // send email
                 // send wathsapp msg
                 System.out.println("sending email ...");
                 System.out.println("sending whatsapp msg...");
             }
         }


      21) What is the Exception Hierarchy and its types
      --------------------------------------------------
      => Throwable class is the root class for all the exceptions classes 
      -> In throwable class Exception class and Error classes are two main sub classes
      -> Exception means any unwanted or unexpected error that occurs during the execution of a program means at the run time of the program
         and this disrupts the normal flow of execution in the program’s .
      -> And Exceptions are divided into 2 Categories 
      -> One is Checked Exceptions and Second one is Unchecked Exceptions
      -> Checked Exceptions means exceptions are checked by the compiler while compiling the code
      -> This are mainly 1) IOException ,2) SQLException ,3) FileNotFoundException ,4) InterruptedException
      -> And Unchecked Exceptions means exceptions which are not checked by the compiler 
      -> Like  Arithmetic Exception, Null Pointer Exception ,IndexOutOfBoundsException ,IllegalArgumentsException

     22) What are the collections have used in your project 
     +++++++++++++++++++++++++++++++++++++++++++++++++++++
     - list . set and map , this are main 3 collection interface I have worked 
     - and in this interface i worked on ArrayList , HashSet and HashMap collections classes
      
     23) Differenc between ArrayList and LinkedList : Note Both are not synchronized
      -------------------------------------------------
      => ArrayList
         ---------
         -> ArrayList is the implementation class of list interface and available in java.util package
         -> ArrayList is used to store the object data in the list format where it used Dynamic Array as internal Data Structure
         -> Insertion order is maintain and data can also access in random format 
         -> We can also implement insert and delete operations on ArrayList but it is slow 
         -> For every new object memory is allocate in continous format

      => LinkedList
        --------------
         -> LinkedList is the implementation class of list interface and available in java.util package
         -> LinkedList is used to store the object data in the list format where it used Double Link List as internal Data Structure
         -> Insertion order is maintain but data cannot access in random format
         -> Data we cannot be access in random format because data is store in nodes and this nodes are connected left and right with another node
         -> Insert and Delete operation are fast with LinkedList 
         -> memory is not allocate in contionus format

      Common points with ArrayList and LinkedList
      -------------------------------------------
      -> classes of List Interface
      -> Duplicates allow 
      -> Nul allow
      -> Insertion order maintain

      22) Differenc between HashSet and LinkedHashSet :Note Both are not synchronized
      -----------------------------------------------
      => HashSet
        ---------
        -> It is the implementation class of Set interface and available in java.util package
        -> It uses Hashtable as data structure to store the object 
        -> Insertion order is not maintain in HashSet class
        -> It allocates low memory and performance wise it is faster than LinkedHashSet

      => LinkedHashSet
         ------------- 
         -> It is the implementation class of Set interface and available in java.util package
         -> It used Hashtable and DoubleLinked List data Structure to store the Object data 
         -> Insertion order is maintain in LinkedHashSet class 
         -> It allocates more memory and Low performance than HashSet because it uses two data structure

      Commom points 
      --------------
       -> Both implements from Set interface
       -> Dublicates are not allowed
       -> only one null is allowed
       -> Both are non synchronized means not thread safe
       -> Both uses Hashing technique to store the data


      23) Difference between HashMap and LinkedHashMap
      -------------------------------------------------
      => HashMap
         --------
        -> It is the implementation class of Map interface and available in java.util package
        -> It uses Hashtable as data structure to store the object in key and value format 
        -> one null key and multiple null values can store in HashMap
        -> Insertion order is not maintain in HashMap 
        -> it uses less memeory and it is fast than LinkedHashMap

      => LinkedHashMap
         -------------
         -> It is the implementation class of Map interface and available in java.util package
         -> It uses Hashtable and DoubleLinkedList as data structure to store the object in key and value format
         -> one null key and multiple null values can store in HashMap
         -> Insertion order is maintain in HashMap 
         -> it uses more memeory and it is slow than HashMap
      Common Points
      ------------
        -> Both implements from Map interface
        -> Both store data in key and value format , one key can null , multiple null values can be
        -> Both are non synchronized means not thread safe

      24) What is difference between TreeSet and TreeMap
      --------------------------------------------------
      TreeSet
      -------
         -> It is an implementation class of set interface and it internally uses binary tree as data structure
         -> TreeSet internally uses natural sorting order to store the data and also we can use custom Comparator provided at the time of creation
         -> In TreeSet nulls are not allows because of natural sorting order
      
      TreeMap
      -------
         -> It is an implementation class of Map interface and it internally uses binary tree as data structure
         -> TreeMap is used to Stores data in key-value pairs, where each key is unique
         -> data is stored in natural sorting order based on the keys’ only or based on a custom Comparator provided at the time of creation
        

       Common points
       -------------
         -> Both uses Binary Tree as a Data Structure 
         -> By default, their elements are sorted by natural ordering. 
         -> Since the elements are already sorted the access and retrieval time becomes faster. 
         -> key cannot allows as null , Value can be Null.
         -> They are defined inside ‘java.util’ package.
         -> Both support Comparable Interface that can be implemented to define a custom sorting order
      
      25) Difference between HashMap and HashTable
      --------------------------------------------
      Hashtable
      ---------
       -> Every Method Present in Hashtable is Synchronized. 
       -> At a Time Only One Thread is allowed to Operate on the Hashtable Object and Hence it is Thread Safe.
       -> Relatively Performance is Low.
       -> null is Not allowed for Both Keys and Values. Otherwise we will get NPE. 
       -> Introduced in 1.0 Version and it is Legacy.

      26) Differenc between HashMap and IdentityHashMap
      --------------------------------------------------
       -> The IdentityHashMap uses equality operator (==) to compare the key and value
       -> while the HashMap uses the equals() method to compare key and value inside the Map.
       -> As the IdentityHashMap doesn't use equals() method it is faster than the HashMap.
       -> IdentityHashMap doesn't require keys to be immutable as it is not dependant on equals().

     
      
      27) What is difference between Interface and abstract class
      -----------------------------------------------------------
      Abstract class
      --------------
       -> Abstract class can have abstract and non-abstract methods.   
       -> Abstract class doesn't support multiple inheritance.
       -> Abstract class can have final, non-final, static and non-static variables.
       -> Abstract class can provide the implementation of interface. 
       -> The abstract keyword is used to declare abstract class.
       -> An abstract class can extend another Java class and implement multiple Java interfaces.
       -> An abstract class can be extended using keyword "extends". 
       -> A Java abstract class can have class members like private,protected, etc.
       -> 9)Example:
              public abstract class Shape{
              public abstract void draw();
               }

      Interface
      ---------
       -> Interface can have only abstract methods. Since Java 8,it can have default and static methods also.
       -> Interface supports multiple inheritance.
       -> Interface has only static and final variables.
       -> Interface can't provide the implementation of abstract class.
       -> The interface keyword is used to declare interface.
       -> An interface can extend another Java interface only.
       -> An interface can be implemented using keyword "implements".
       -> Example:
              public interface Drawable{
              void draw();
              }
 
     
      28) What are the methods available in Object class
      --------------------------------------------------
       => Object class available in java.lang.Object package and provide multiple methods like
            Method                                   Description
            ================================================================================
            toString()             Returns a hashcode value of the object.
            --------------------------------------------------------------------------------
            hashCode()             Returns a hash code value for the object. seperate hashcode required the override
            --------------------------------------------------------------------------------
            equals()               Compares objects hashcode equal or not 
            --------------------------------------------------------------------------------
            clone()                Creates a shallow copy of the object.
            --------------------------------------------------------------------------------
            getClass()             Returns the runtime class of the object.
            --------------------------------------------------------------------------------
            finalize()             Called before garbage collection for cleanup (deprecated). not use from java 9
            --------------------------------------------------------------------------------
            wait()                 Causes the current thread to wait until notified.
            --------------------------------------------------------------------------------
            notify()               Wakes up one thread waiting on the object's monitor.
            --------------------------------------------------------------------------------
            notifyAll()            Wakes up all threads waiting on the object's monitor.
            --------------------------------------------------------------------------------



      29) What are the changes in java 8 explain   java 8 2014 -> total 10 changes
      ------------------------------------------(FILM CD SOSS)--------------------
      -> In java 8 the most important changes are lamda ex, stream api, interface changes , functional interface , optional class , method ref
       ->   1) Interface changes
               1: Default Methods
               2: Static Methods
            2) Functional Interface                        // so this are the important changes they have done in java 8
               1: Predicate
               2: Consumer 
               3: Supplier
               4: Function
            3) Lambda Expression 
            4) Method Refrence and Constructor Refrences
            5) Stream Api    MMMMIMP ***** for Experience
                 After data store in collection then to process the data we use Stream API
            6) Optional class ( to avoid null point exception because null point exception is very comman )
            7) Spliterator ( special iterator)
            8) StringJoiner
            9) Collection FrameWork changes
            10) Date and Time api

      30) Expalin nullPointerException in java
      -----------------------------------------
      => - When we perform some operation on null value then we will get NullPointerException
         - If we get Exception means our application is abnormally behave
         - To avoid NullPointerException we have to implement null check before performing operation on the Object like below
              String s = null;
              s.length()  // NPE
              if(s! = null){
                 sysout( s.length);
              }
          note: In the project there is no gaurantee that programmer will implement null checks. 
          If any body forgot to implement null check then program will run into nullPointerException
          To avoid this problem we need to use Optional class 

      

      31) Explain Optional class in java
      -----------------------------------
      =>-> optional means data may available , data may not available
        -> if we dont use Optinal class , then we get data directly to perform operationa
        -> if we use Optional class then we dont get data directly , we get data in object format
        -> we write complex logic but forgot basic logic then no use of complex logic
        -> java.util.Optional class introduced in java 1.8 v.
        -> Optional class is used to avoid NullPointerExceptions in the program
        -> when we perform any operation on null value then we get NullPointerException
           ex :  userName.toUpperCase();  
           here userName is getting null from DB and we perform operation on that user 
        -> getting  NullPointerException is very common in real project
        -> before Optional how developer check NullPointerException
           ex:
            if(userName=null){
                String msg = userName.toUpperCase();
            }else{
                Sysout "Invalid userName"
            }
            // but every developer us not a good programmer who can check the null value  , so java people introduce in Optional class to avoid this exception
        -> In Optional class data is present in Object format , we cannot get direct data 
        -> we need to check first data is present or not then get that data
             isPresent() - to check data is present in Optional object 
             get()       - to get object data and perform the operation
             Note in get() also gives you object data only  
             if(userName.isPresent()){
                 userName.get();   // object data only
                 String name = userName.get();
                 sysout(name.toUpperCase());  // operation is perform
              }
     32) Difference between method OverLoading and Method Overriding -> 8 points each 
      ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      =>Method Overloading
      --------------------
       -> If two or more methods with the same name and with different parameter list then it is said to be method overloading
       -> In method overloading return type can be same or can be different
       -> Methods can be overloaded in the same class also
       -> Methods can be overloaded in inheritance also
       -> In Method overloading , access modifier can be same or different
       -> final , static ,private methods can be overloaded
       
      => Method Overriding
      --------------------
       -> If two or more methods with the same name and with same parameter list then it is said to be method overiding
       -> In method overriding return type must be same except co-varient return type
       -> Methods cannot be overeiden in the same class because ambiguity to call
       -> Methods can be overriden in inheritance only
       -> In Method overriding , overriding methods can have same access modifier or less restrictive access modifier (Must not be more restricitve)
       -> final  methods cannot be overridden because final keyword used to prevent method overriding
       -> Static  methods cannot be overridden because static members do not require object to call
       -> private  methods cannot be overridden because private members cannot be inherited

      
      
      --------------------------------------
   33) Explain Functional interface in java
      ----------------------------------------
      -> Functional interface is an interface which has only one abstract method. and that interface is annoted with @FunctionalInterface 
      -> It can have any number of default methods, static methods, and methods inherited from the Object class.
      -> The primarily used of Functional Interface is used to invoke the lambda expressions, 
      -> Another implement a functional interface is used for method references, which allow you to refer to an existing method 
         that matches the signature of the interface's abstract method.
      -> Predicate , Consumer , Supplier , Functional these are the common Functional inteface
      -> Predicate -> It is used to check condition and return true or false value. , Predicate<Integer> p= i -> i>10 , sopln(p.test(5)) , output : true
         Consumer ----------> will take input           -------> will not return anything => accept() as abstract method
         Supplier ----------> will not take any input   -------> returns output => get() as abstract method
         Function ----------> will take input           -------> will return output  => apply() as abstract method

   34) Explain Method refrence in java (:: refrence operator)
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   -> In Java 1.8 it introduce , a method reference is a shorthand technique to call a method directly using the ::(refrence) operator. 
   -> Method refrence only refer the existing methods either static or instance or constructors without explicitly calling them.
   -> We use method references when we have a functional interface with a single abstract method i.e (SAM interface) and 
      whose method signature matches the method we are referencing.
   -> Commonly we use Method refrence in Stream operations, functional interfaces like Supplier, Consumer, Predicate, and Function.
   -> The common Benefits of Method References are 1) Improved Readability 2) Reusability 3) Avoid Boilerplate Code
   -> EX:  Static method refrence s 
           @FunctionalInterface
            interface Operation{
              public int calc(int a , int b);
            }
           -----------------------------------------
            class Calc{
              public static int add(int a , int b){
              return a+b;
              }

              public static int sub(int a , int b){
              return a-b;
              }
            }
            -----------------------------------------
            class Main{
              public static void main(String[] args){
                  Operation obj = Calc::add; // Calc::sub  // without paranthesis
                  sysout(obj.Calc(10.20));
              }
            }
    -> EX : Instance method refrence 
           @FunctionalInterface
            interface Operation{
              public int calc(int a , int b);
            }
           -----------------------------------------
            class Calc{
              public int add(int a , int b){
              return a+b;
              }

              public int sub(int a , int b){
              return a-b;
              }
            }
            -----------------------------------------
            class Main{
              public static void main(String[] args){
                  Calc cobj = new Calc();
                  Operation obj = cobj::add; // Calc::sub  // without paranthesis
                  sysout(obj.Calc(10.20));
              }
            }
   35) What is Lambda expression in java
   ++++++++++++++++++++++++++++++++++++++
   -> Java is called as OOP language , Everything will be represent using Classes and object .
   -> But From 1.8v onwards Java is also called as Functional Programming Language because of Lambda expression
   -> In OOP Language Classes and object are main entities . we need to write methods inside the class only.
   -> Functional Programming means everything will be represent in the form of functions .
      Functions can exist outside of the class . 
      Function can be stored into a refrence variable . 
      A function can be passes as a parameter to other methods.
   -> Lambda Expression introduced in java to enable Functional Programming.
   -> Lambda function is store in variable , that variable belongs from Functional Interface
   -> Lambda is an anonymous function ( means function without name)
        -No Name ,No Modifier , No Return Type
        () -> {}  , () method ,-> arrow bind () and {},{} body
   -> To call the Lambda function -  Functional Interface is use  , because Lambda is anonymous function

   36) Expalin the Fail Safe Collections IdentityHashMap , ConcurrentHashMap ,WeakHashMap
   --------------------------------------------------------------------------------------
   =>
   37) What is different between ConcurrentHashMap and HashMap

  38)What Are HTTP Status Codes? Explain
      +++++++++++++++++++++++++++++++++++
      -> Every REST API method should be mapped to HTTP Method if that method is provider or consumer
      -> Http methods are mainly 4 they are get,post ,put and delete
      -> When client send the request to server then along with the data server is also send the status code 
      -> There are 5 main types of status codes 
      -> Status code which are start form 100 to 199 they are related to Information(Information provide sucessfully)
                                          200 to 299 - related to Success (OK) ( get successfully response from server to client)
                                          300 to 399 - Redirection  (we send request to one server and that server send your request to another server)
                                          400 - 499  - Client Error
                                          500 - 599  - Server Error
        ->  200   OK                    [your request is process successfully]
        ->  201   Created               [ for post request we use , reuest process and created]
        ->  204   No Content            [request is processed but server nothing to return]
        ->  400   Bad Request           [incorrect information you are sending]
        ->  404   Not found             [URL is incorrect ]
        ->  405   Method not allowed    [request method is bind to get but you are sending post request]
        ->  406   Not Acceptable        [server providing json but you are accepting xml]
        ->  415   Unsupport Media Type  [ what ever the content we are sending that is not supported by server]
        ->  500   Internal Server Error  

      ----------------------------------------------------------------------------------------------------------------
      18 imp status codes 
      ---------------------
      - 200 OK: Request succeeded
      - 201 Created: Resource created
      - 202 Accepted: Accepted request
      - 204 No Content: Accepted request
      - 301 Moved Permanently: Accepted request
      - 302 Found: Temporarily moved
      - 304 Not Modified: Not modified
      - 400 Bad Request: Bad request error
      - 401 Unauthorized: Needs authentication
      - 403 Forbidden: Access Forbidden
      - 404 Not Found: Resource Not Found
      - 405 Not Allowed: Method not allowed
      - 408 Request Timeout: Request timed out
      - 500 Internal Server Error: Server error
      - 501 Not Implemented: Not implemented
      - 502 Bad Gateway: Bad gateway error
      - 503 Service Unavailable: Service unavailable
      - 504 Gateway Timeout: Gateway Timeout
      ----------------------------------------------------------------------------------------------------------------

  39 What is Maven , its use , its goals , terminology used in maven , scope of maven , Repository of maven  
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       ->  www.mvnrepository.com
       ->Maven is one build tool , Build tool because it is used to automate -  project build process" in the form of
          a) downloading the dependencies and configured that dependencies automatically.
          b) Compile sourece code 
          c) Execute unit test cases (JUnit) 
          d) package application into jar or war 
             jar - for stand alone application
             war - for web application
       -> Maven is developed using java language
       -> The main aim of maven is to simplify java projects build process.
       -> Maven goals
          ----------- 
          mvn clean package => clean + compile + test + package
          mvn clean install => clean + compile + test + package + install
          - clean  : delete our .class files
          - compile : to compile our source code
          - test : to perform unit test cases
          - package  : to package in jar or war file
          - install  : to install the dependency  into our local repository from artifact repository,
       -> Maven Terminology
       ---------------------
            1) Archetype : Type of project (quick-start / web)
            2) groupId : Organization Name (in.ashokit)
            3) artifactId : Project name
            4) version : SNAPSHOT / RELEASE
            5) packaging : jar or war
            6) dependencies : libraries (jars)
            7) Repositories : dependencies location 
       -> Maven repositories 3 types
        -----------------------------
            1) Central Repository (public)  
            2) Remote repository (private -> company specific)(Nexus/Jfrog)
            3) Local Repository (in our machine) -> .m2
       -> Maven Dependency Scope  decide when maven should load that dependency into our application.
        -------------------------
            compile    : dependency added at compile time
            runtime    : dependency added at run time
            test       : dependency added when unit test is happent
            provided   : provided means at what time dependenct to provide at compile or at runtime
            system     : system means a jar we want to load only
            import     : when one project import dependecy from another project then we go for import
       -> Maven dependency exclusion concept.
        -------------------------------------
         -> if we want remove some child dependencies then we need to use dependency exclusion
            <exclusions>
               <exclusion>
                  <groupId>org.springframework</groupId>
                  <artifactId>spring-aop</artifactId>
               </exclusion>
            </exclusions> 
       -> How to customize project build jar or war name ?
         -------------------------------------------------
                             
    40) What is Git and What are the Git commands you use in your project
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       Git : - GIT is one Version Control Software , Version Control Software means One Project have multiple developers 
       -----
             - And this multiple developer are working from multiple location like India , australia , america etc ..
             - To integrate all the developers code at once place and To monitor/track their code changes
             - for  that we Version Control Softwares like GIT , Bit Bucket etc
             - In git hub we create the project repo and store source code at once place 
             - Anyone cannot access the Project source code because of monitored access. 
       GIT Architecture : 
       ------------------
             - Working Tree      : git init        
             - Staging Area      : git add . ( dot means all files in staging area)( for specific git add pom.xml)   
             - Local Repository  : git commit -m ' first commit' (-m represent message  for commit)      
             - Central Repository: git push -u origin main
                                   Note : if 1st time push , execute this 3 commands execute only one time
                                   git branch -M main   // this 3 commands execute only one time
                                   git remote add origin git@github.com:NileshNangde/App1.git
                                   git push -u origin main
       GIT Commands :
       ---------------
             - git help   : to get all  common commands 
             - git init   : To initialize working tree   
             - git add .    (dot is compulsory) : To add files to staging area
             - git status : To check staging area status
             - git commit : Send files from staging area to local repo
             - git push   : To push latest changes from local repo to remote repo
             - git pull   : To get latest changes from central to local
             - git restore: To discard working tree changes & to unstage the file
             - git clone  : To download central repo to local machine
             - git log    : To get repo commit history
             - git rm     : To remove file (rm + commit + push)
             - git branch : to  check which is your working branch
         MIMP Diff
         ---------
               1)  git clone vs git pull
               2)  git push  vs git pull
               3)  git stash   and git stash apply
               4)  git fetch vs git pull
               5)  git merge  vs  got rebase

               => git fetch : download latest changes from remote repo to local repo .
                              changes not reflect in working tree , if you want to download from local to working tree then again git pull
               => git stash : save our changes from working tree are to some temperory area 
                              when high priority task is completed then apply git stash apply command to get my changes back again
                             ex: bug 128 
                              I make changes from 9 am to 11 am , manager call me at 11am 
                              work on bug 130 having high priority , then i do git stash on 128 bug  and work on bug 130 , 
                              after 130 bug got complete , push that code on remote repo , and do git stash apply to get all 
                              work back of 128 bug as it 
        What is git conflict ?  
        ------------------------
         => When we are merging central repo changes with local repo then we may get conflict.
         => If two persons working on same file then we may get conflicts problem.
         => When conflict occurs we have to resolve those conflicts and we have to commit without conflicts.
            Note: When we execute 'git pull' command there is a chance of getting conflicts.

  41) Explain what is Agile Technology
  +++++++++++++++++++++++++++++++++

    Agile:  -> Software are develop with the help of SDLC process.
    -----   -> SDLC contains several phases like Requirements Gathering , Requirements Analysis , Designing , Development ,Testing ,Deployment ,Support
            -> The SDLC methodologies are Waterfall (outdated) and Agile  (trending)
         Waterfall Mode: Develop softwares in linear format , client involment is less , so client not happy
         --------------
         Agile Model   : -> One apporch to develop software in parallel process 
         -------------   -> In Agile model ( planning + development + testing + deployment ) is a continuos process.
                         -> Project functionalitiy will be divided into multiple sprints/releases. // this sprint are going to releases and deploy
                         -> Client involvement , feedback is very important is Agile model.
                         -> Requirements & Budget is not fixed in Agile.
         Agile Team      1) Product Owner  : Responsible for client deliverables.
         ----------      2) Scrum Master : Responsible to manage the team.  [  Product owner and Scrum Master both are Non tech MBA background]
                         3) Tech Lead : Responsible for solving technical challenges.
                         4) Team members : developers + testers (Note: Industry standard agile team size is 7 to 10 only.)
                           Every agile team will have one tech lead & one scrum master.
                           One project can have multiple agile teams also.(like ticket booking  one agile team , payment gateway one tem)
         Agile Terminology   1) Backlog Grooming     : meeting in which we discuss pending works in the project.
         -----------------   2) Story & Story Points : every pending work one story will be created in jira,Story points represents duration to complete the story.
                                                       3 points 1 day  or sometimes 1 points 1 day depending the task
                                                       5 points => 2 days
                                                       8 points => 3 days
                             3) Sprint Planning      : meeting in which we will discuss about priority stories to complete. 
                             4) Sprint               : means fixed set of stories targeted to be completed in given time.
                             5) Scrum                : Scrum call is a meeting in which we will discuss agile team work updates.
                                                       1) What i am doing 2) Status of my story 3) When it will complete 4) Any challenges to complete
                             6) Retrospective or     : meeting in which agile team will discuss about previous sprint which we completed.
                                Retro meetings         Note: Retro happens monthly once.  
                                                       Retro is like a review meeting. in retro we will discuss
                                                      - what went well
                                                      - what went wrong
                                                      - what lessons we learnt
                                                      - what new ideas we get

  42) Explain where you use JIRA Software
   ++++++++++++++++++++++++++++++++++++++
       -> JIRA is project management software 
       -> For our project what ever the  Story assignment , story development , Bug reporting status we give on jira only
       -> Also Sprint Reports , Project Tracking status we get on JIRA only
     
  43) For What purpose you use SonarQube in your application
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++
       -> Actually I used SonarQube for code review purpose
       -> code reviews are 2 types 1] using software : SonarQube 2] Peer review - fresher code review by senior team member)
       -> We do code review for identify the mistakes in code , code review we can provide quality code and bug free code
       -> With the help of SonarQube we can identify 
                              1) Bugs
                              2) Vulnerabilities     (वल्नरेबिलिटी ) (security issues)
                              3) Code Smells         (repeated string literals, unused imports, unused method params)...
                              4) Duplicate Code blocks
                              5) Code Coverage       (no.of lines tested using junit -> 80%) 
       -> SonarQube will not check our logic is correct or not , it will check are we following the best practice of java to develop the application or not
    How background SonarQube is communicate with Our application
    ------------------------------------------------------------
       -> Sonar server is configured with Jenkins pipeline 
       -> As a developer I will run jenkins pipeline and I will check sonar dashboard for code review report.
       -> Based on sonar report, we have to fix sonar issues in code.
          Note : For new joinees below tasks will be assigned in first 3 months..
               1) sonar fixes
               2) Implement Unit test cases
               3) Improve Code coverage for the project (80 %)
               4) Bug fixing
  
  44) How do you manage runtime root cause of your application , what is Logging and why and its levels 
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ 
    -> In my application the runtime root cause of the application is managed by Logging concept and the execution details are store in log files
    -> and with the help of logging we can identify root cause of the exception. Log4J framework we use for logging
    -> Logback  , this is default logging framework used in spring boot to generate log messages and INFO is the default level
    -> Logging Architecture is divided into 3 parts 
    ->   1) Logger    -> This is one class which provides methods to write log msgs
                      -> ex : trace(), debug(), info(), warn(), error()
                      -> private Logger logger = LoggerFactory.getLogger(MsgService.class); ( 1st create logger object For every java class )
                        @Service
                        public class MsgService {
                           private Logger logger = LoggerFactory.getLogger(MsgService.class);
                           public String getWelcomeMsg() {
                              logger.info("getWelcomeMsg() - started...");
                              String msg = "Welcome to Ashok IT";
                              logger.info("getWelcomeMsg() - ended....");
                              return msg;
                           }
                        }
         2) Layout    -> This represents log msg pattern in the form of data,time,log-level,class-msg,thread etc..
         3) Appender  -> THis Appender represent on which destination the log msg are to print in ConsoleAppender or in FileAppender 
    -> What are the diff Logging Levels  -> Log msgs will be stored to log file based on log level
    ------------------------------------ 
         -> TRACE  : is used to store every line execution details
         -> DEBUG  : is used to store execution flow at low level      DEBUG => DEBUG + INFO + WARN + ERROR
         -> INFO   : is used to store execution flow at high level     INFO  => INFO + WARN + ERROR
         -> WARN   : is used to store warnings in code execution flow  WARN  => WARN + ERROR
         -> ERROR  : is used to store execptions occured in code flow
         -> Note: In springboot, default log level is INFO.  
    -> How to change log level in the application using below property
     --------------------------------------------------------------
         -> logging.level.root = WARN
    -> How to print log messages in file 
    ------------------------------------
         -> logging.file.name=app.log   in app.properties
    -> What is Logging with Rolling
    ------------------------------
         -> Rolling is one mechanism , and this mechanism is used to avoid to make the large files of log messagees
         -> basically what happent when we store the log messages in file then day by day files size is going to big 
            and this file is not open , or load , or having lot of log messages
         -> To avoid this problem Rolling mechanism introduce and it is implemented by 2 ways 
         -> 1) Size Based Rolling   -> upto 1 GB log file size reach new file crated
            2) Time Based Rolling   -> to create every day new log file
            // Reamining  -> How to do this
    -> What is the diff between SLF4J and Log4J ?
    ---------------------------------------------
         -> SLF4J -> means Simple Logging Facade for Java (SLF4J)
         -> This is java library which is used by different logging framework( like Log4J , logback)
         -> Because of this library we make log messages loosely coupled to our appication

         -> Log4J -> Logging framework to track the application we the help of log messages
            ------
    -> What is Log Monitoring
    --------------------------
         -> Our application is running on Linux machine , and if any runtime error cause in application , 
         -> To find the root cause of that abnormal termination of the application we tract the log messages which are available in log files 
         -> Reading the Log messages means Log Monitoring 
         -> To read the Log messages we use diff tools /applications like Putty / MobaXtream , ELK , splunk etc , I use MobaXtream

  45) What is Testing , Isolated testing , Integration testing , Unit testing , JUnit , Code Coverage , Mocking
    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
        -> Testing  : Testing we do to test the component functionality code is working properly or not as we designed , and give bug free code to higher testing Enviorment
          ----------  or the Process of verification and validation is called as Testing.
        -> Isolated Testing :  same as Unit testing , controller service not call service class service , testing only controller service indivisually
          -------------------- 
        -> Integration Testing : means entire application end to end flow testing
          ----------------------
        -> Unit Testing : Testing individual components of the application ex: one controller method 
          --------------- As a developer I am responsible for Unit testing , to provide Bug free code for higher Enviorments Like SIT , UIT etc
        -> Junit  :  Java Framework to perform Unit Testing  ,Junit 5 v for testing java 8 and above
          ----------
        -> AsserJ  :
          ---------
        -> Code Coverage : For code coverage we need to add external Jacocco dependency , this provide the UI which represent how many lines are executed in Unit testing
          ---------------- Industry standard is minimum 80% code coverage for the project.
        -> Mocking :  To write the test cases we use Mockito object , insted of controller call service it call mockito 
          ----------- Mocking means  the  process of creating substitute object for real-object is called as Mocking.
                      To perform mocking we have mocking framework - Mockito  Framework . 
                      Mokito 3.x v for java 8 and above 
         Annotations used in unit Testing and how to run test cases
         -----------------------------------------------------------
                -> 1) @Test - represent method as Unit test method
                -> 2) @WebMvcTest(Controller = msgController.class)  when controller class represent Unit test
                -> 3) @SpringBootTest - ( for service , Dao class or normal class ) to represent class as unit test class
                -> 4) assertEqual(expectResult , actualResult) - to verify actual result with expect result 

                - Run Unit test program as Junit test 
                - green color means test successs
                - red means fail
       
         Note: 'spring-boot-starter-test' dependency to perform unit testing. , By default added

         How to perform Unit testing for the REst API in the Spring 
         ------------------------------------------------------------
         How to perform unit testing for private methods 
         -----------------------------------------------

   46) What is performance testing and what is JMeter
      +++++++++++++++++++++++++++++++++++++++++++++++
         ->  Process of verification and validation is called as Testing.
         ->  Software Testing will happen in multiple stages
            1) Unit Testing                 :- Testing individual components of the application , Developers will perform unit testing using Junit.
            2) System Integration Testing   :- Testing team will perform system integration testing. Team Identified bugs will be reported using JIRA.
            2) System Integration Testing   :- 
            3) Performance Testing          :- Checking application stability and responsiveness.
            4) User Acceptance Testing      :- client or client side team will test our application before delivery
                                               Note: Based on UAT client will decide GO or No-GO.
                                               Go means it is green signal from client to deploy in production.
                                               No-GO means client identified some issues in UAT hence production deployment got cancelled.


         -> Performance Testing : Checking application stability and responsiveness.
           --------------------  For ex :
            1) how many users can access at time ?
            2) for 100 users what is avg response time ?
            3) for 1000 users what is avg response time?
            ....
            4) for 1 lakh users what is avg response time?
            5) what is bottleneck/failure-point of the app ?
         -> Note: To implement performance testing we will use tools  Ex: JMeter, HP Load Runner    

         JMETER
         ------
         -> JMETER is a free & open source software given by Apache Organization
         -> JMETER is used for performance testing
         -> Performance testing means the process of verifying stability & responsiveness of the application
         -> How our application is responding for different work loads we can verify using JMETER
         -> Using JMETER we can create virtual users to test our application performance
         -> JMETER is a java based desktop application
         -> Using JMETER we can test performance of any web application
         Note: We can't implement performance testing manually
            What is the response time of our application for 100 users ?
            What is the response time of our application for 200 users ?
            What is the response time of our application for 300 users ?
            What is the response time of our application for 400 users ?
            What is the response time of our application for 1000 users ?

         -> We need to provide application performance details to client
         -> If application performance is slow then we need to troubleshoot the issue and we need to fix it.

   47) What is Exception and How do handle exception in your REST API's
   +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   Exception : -> The term exception is to handle any exception or any error which occurs in our application
   ----------  -> What ever the applcaiton we are developing exception has to be handle for that application properly
               -> And it is the must have feature in any application either it is small or big application
               -> So when we talk about REST api's , that api must handle exception properly , so it can give proper response back to client 
               -> WHat ever the particular api is called by the client , and if any problem is occurs in that api call due to any reason 
               -> That api should be retrun the porper reason back to the client , so that client will inform that there is some problem is occured in that rest api
               -> Those response must not be misleading to the client 
               -> In rest api the 2 main annotation is used to handle the custom exception  
                   1) @RestControllerAdvice -> This annotation is used to handle the exception globlally that occured in the controller classes
                   2) @ExceptionHanlder     -> THis annotation is used to hanlde the specific exception and send custom response back to the cleint 
                                            -> that means , a proper response which ever we want to write , which ever wwe think, the client should be understand 
                                            -> WHy problem has occured , these custom response is called with the help of @ExceptionHandler annotaion

  48) How to create the Singleton class in Java
  ++++++++++++++++++++++++++++++++++++++++++++++++++++++
  -> The real time usage of the singleton class is suppose I want to create one class which I want to connect with the database
  -> and after that I will perform the Database querries like Insert , Update , Delete 
  -> If my class is not singleton then , every single queryy I need to connect that class with the Databse 
  -> Because of the singleton class I will connect one time class to the Database and perform multiple insert , update , delete querry
  -> To create a singleton class in java for that we have 3 main important points
      That class  1) object must the private static   // private means this object access within the class only
                                                      // static is for class not for the object means 100 object even I create then only same
                                                         refrence for that object
      That class  2) Constructor must be private      // constructor is private so nobody create the object using new keyword ex : new DBCOnncetion()
      That class  3) have public static method which is returing the class object  // this method for suppose some body wants this class object 
                                                                                      then through this class method then can call this class object
  -> Ex 1 : => Eager Initialization    -> problem with Eager Initialization coding is object is created at execution time 
   --------------------------------       even we dont create the object for the class , memory is created if we dont use , so memeory wastage 
           -> Ex: public class DBConnection{

                    private static DBConncetion conObject = new DBConnection();
                    private DBConncetion(){
                    }
                    public static DBConncetion getInstance(){
                    return conObject();
                    }   
                  }
               --------------------------------------
                  public class Main{

                    piblic static void main(String[] args){
                      DBConncetion conObject =DBConnection.getInstance();
                    }
                  }
  -> Ex 2 : => Lazy Initialization => here we dont initializa the object we check first object is null or not if null then create the object
  --------------------------------    But here problem is it checks 2 null so 2 object is created , 1st is at initialize side 
                                      2nd is at conObject == null side , so 2 thread paralley executed
           -> Ex: public class DBConnection{

                    private static DBConncetion conObject;
                    private DBConncetion(){
                    }
                    public static DBConncetion getInstance(){
                    if(canObject ==null){
                    conObject = new DBConnection();
                    }
                    return conObject();
                    }   
                  }
  -> Ex 3 : => Synchronized the method  =>  // here synchronized method allow only one method , here lock and unlock is there  
  ------------------------------------      // 2 method creation it will lock and unlock that method
                                            // but here problem is this method is slow , suppose we call the getInstance method sequencially 100 times
                                               1st it check null , and 2nd because of synchronized 10 times lock and unlock will happent
           -> Ex: public class DBConnection{

                    private static DBConncetion conObject;
                    private DBConncetion(){
                    }
                    synchronized public static DBConncetion getInstance(){
                    if(canObject ==null){
                    conObject = new DBConnection();
                    }
                    return conObject();
                    }   
                  }
              
  49) How to create the Immutable class in java
  +++++++++++++++++++++++++++++++++++++++++++++
  -> Immutable class means once object is created for the class the state(variables value) cannot be modified
  -> In real time all Wrapper classes are the immutable classes there value we cannot changed
  -> So the next Q is how to control this , for that we have set of rules 
   Rules :
    -------
      Rule 1) class must be declare as final -> so it avoid inheritence
      Rule 2) variables must be private and final 
      Rule 3) parameterized constructor should use to initialize all the fields of variables because setters not allowed
      Rule 4) Because of variables decalred with private only getters we can access them 
  Ex : 
               final class Immutable {                  // class final 
                  private final String name;            // variables private and final 
                  private final int date;
                  
                  public Immutable(String name, int date) {   // variables only initialized through constructor 
                      this.name = name;
                      this.date = date;
                    }

                  public String getName() {                   // only getters to get the values because variables are declare as private 
                   return name;
                  }
                  public int getDate() {
                   return date;
                  }
               }

               class Main {
                 public static void main(String[] args) {
                   Immutable obj = new Immutable("Programiz", 2011);
                   System.out.println("Name: " + obj.getName());
                   System.out.println("Date: " + obj.getDate());
                 }
               }

  50) Explain the difference between Callable interface and Runnable interface
  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    -> In Java both Callable and Runnable interfaces are designed in such a way that they are going to be execute the single tasks on multiple threads 
    -> Here in 
    -> Runnable Interface 
    ----------------------
         -> The Runnable interface is designed in such a way that it is going to execute the task on multiple threads but the run() method 
            does not Return a value or any outcome: The task's 
         -> Means the task is  success or failure is not communicated directly to the caller.
         -> available in java.lang package
         -> It have public void run() method which is not return any result when thread is executed
         -> The run() cannot throw any checked exceptions
         -> And this Runnable interface is suitable for the tasks where no result is required ex :notifications to send 
         -> It works with Thread and ExecutorService Framework
    -> Callable Interface
    ------------------------
         -> The Callable interface is designed in such a way that it is going to execute the task on multiple threads and the call() method 
            Return a value or any outcome
         -> Means if the task is  success or failure is  communicated directly to the caller.
         -> available in java.util.concurrent package
         -> It have public V call() method which throws checked Exception
         -> call() method return type is Future object either primitive data type or Object 
         -> It works on ExecutorService and Future 
         -> It is  suitable for tasks where a result or exception handling is required.
    -> Runnable Interface code
    ---------------------------- 
             class MyRunnableTask implements Runnable {
                   @Override
                   public void run() {
                       System.out.println("Task is running using Runnable!");
                   }
              }
             public class RunnableExample {
                   public static void main(String[] args) {
                       Thread thread = new Thread(new MyRunnableTask());
                       thread.start(); // Executes the task
                   }
               }
    -> Callable Interface code
    --------------------------
              class MyCallableTask implements Callable<String> {
                   @Override
                   public String call() throws Exception {
                       return "Task completed and returning result using Callable!";
                   }
               }
            -------------------------------------
               public class CallableExample {
                   public static void main(String[] args) throws Exception {
                       ExecutorService executor = Executors.newSingleThreadExecutor();
                       Callable<String> callableTask = new MyCallableTask();

                       // Submit task and get Future
                       Future<String> future = executor.submit(callableTask);

                       // Get result from Future
                       String result = future.get();
                       System.out.println(result);

                       executor.shutdown(); // Shut down the executor
                   }
               }
   51) What is ExecutorService Framework 
   ++++++++++++++++++++++++++++++++++++++
      -> ExecutorService is an tool / Framework available in java.util.concurrent package and it is used for managing and controlling threads
         in preffered order in multithreding
      -> ExecutorService is going to be simplifies the thread management like how threads are created, managed, and executed.
      -> ExecutorService provide services like 
          -> Thread Pool Management:
             It manages a pool of threads, reusing them for executing multiple tasks, which improves performance by avoiding the
             overhead of creating and destroying threads repeatedly.
          -> Task Submission:
             TO submit tasks for execution using methods like execute(), submit(), or invokeAll()
          -> Result Handling:
             For both Runnable and Callable tasks it allows tasks to return results and handle exceptions via Future objects.
      -> TO use the  ExecutorService , 
            Rule 1 : create ExecutorService , Executor provide method like
                     For Single-threaded Executor: ExecutorService executor = Executors.newSingleThreadExecutor();
                     FOr Fixed Thread Pool:        ExecutorService executor = Executors.newFixedThreadPool(4); // 4 threads
                     For Cached Thread Pool:       ExecutorService executor = Executors.newCachedThreadPool();
                     For Scheduled Thread Pool:    ScheduledExecutorService executor = Executors.newScheduledThreadPool(2);
            Rule 2 : Submit Tasks
                    -> execute() - for Runnable Interface 
                    -> submit()  - for both Runnable/Callable
                       submit() Executes a task and returns a Future to retrieve the result or handle exceptions


  52) Explain @RequestBody Annotation detailly
  ++++++++++++++++++++++++++++++++++++++++++++

  53) Explain Transient Keyword  with Coding Example
  +++++++++++++++++++++++++++++++++++++++++++++++++++
  => To understand Transient keyword , first we need to understand what is Serilization and DeSerilization
  -> Serilization :  means java class variables data  means java class object data is convert into byte and store into file format  
  ------------------ here JVM convert this objectdata into byte format 
  -> DeSerilization : means reverse of Serilization , file byte data is convert into Java object format 
  ------------------
  -> Now Transient means : When we declare the variable with Transient keyword then , during Serilization JVM not convert that varible data into 
                           byte format , JVM store the default values in the Serilization process 
  -> This Transient key we use , whenever there is 1) any Securuty consern in data , 
                                                   2) Data that should not be saved in serilization
                                                   3) Any Temporary data 
  -> Demo Example 
  -----------------
   public class Student implements Serializable{

       public int studNo;
       public String studName;
       public String studResult;
   -------------------------------
   public class SerializationDemo{
        public static void main(String[] args){
        Student s1 - new Student();
        s1.studNo=5;
        s1.studName = "Nilesh";
        s1.studResult = "fail";

        String fileName = "D:\\nilesh\testfile.txt";
        try{
        FileOutStream fos = new FileOutputStream(fileName);
        ObjectOutputStream oos = new ObjectOutputStream(fos);
        oos.writeObject(s1);

        oos.close();
        fos.close();
        }catch(FIleNotFoundException e){
           e.printStackTrace();
          }catch(IOException e){
             e.printStackTrace();
            }
         }
   }
   ------------------------------------
   public class DeSerilizationDemo{
       public static void main(String[] args){
       String fileName = "D:\\nilesh\testfile.txt";
       try{
       FileInputStream fis = new FIleInputStream(fileName);
       ObjectInputStream ois - new ObjectInputStream(fis);

       Student obj = (Student).ois.readObject();
       System.out.println(obj.studNo);
       System.out.println(obj.studName);
       System.out.println(obj.studResult);

       oos.close();
       fos.close();
        }catch(FIleNotFoundException e){
           e.printStackTrace();
          }catch(IOException e){
             e.printStackTrace();
            }
         }
   }

  54)  Explain Volatile Keyword in java
  +++++++++++++++++++++++++++++++++++++
   -> When we declare the variable as volatile then the , then this volatile variable is directly store the value into 
      the main memory not in cache memory . to avoid the inconsistency in data
   -> We have 3 memories like Cache memory , main memory(Ram) and and Hard Disk 
   -> Suppose in my account I have 500Rs allready , and I want to pay 1000Rs to some one , I call my family to send me 500 Rs 
   -> so my father send me 500 Rs , now in my CPU thread 1 is execute , and in cache memory it store 1000RS
   -> Now again my Mom also send me 500RS , for that in my CPU thread 2 execute and it store 1500RS in cache memory
   -> Now I pay 1000 RS to some one for that Thread 1 is executed and it read the thread 1 cache memory and minus 1000 and remains 0 as balance
   -> Now here inconsistency of data occur because data is not read from main memory , so each Thread which execute is not read data from main memory
   -> If I declare the variable as Volatile then each thread is going to be directly communicate with main memory not in cache memory
   -> So inconsistency of data is not going happent 

  55) How to write the Junit test cases to the private methods
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
         -> When we declare the method as private , then as per the Access Modifier rules we cannot access those methods outside the class 
         -> But for Unit testing we test the individual methods working properly or not 
         -> To write the test cases for private methods we have 2 ways
              1st one is 
              -----------
             1) Calling private methods from the public method and write the Junit test cases for the public method and cover all use cases of private method 
                (But here problem is if the method contains complex logic then through public method all private uses cases are not cover to test ) , so this cause defect after later testing
              2nd one is 
              -----------
             2) Reflection

          Ex : 
          -------
            public class Library{

                private int sumOfTwoNumbers(Integer a , Integer b){
                return a+b;
                }

                public int sumOfNumbers(int a , int b){
                return a+b;
                }
            }

            1st how to write test cases for public methos   -> run as Junit
            ------------------------------------------------
            public class LibraryTest{
               @Test
               public void testSumOfNumbers(){
                    Library library = new Library();
                    int sum =  library.sumOfNumbers(10,30);
                    assertsEqual(40 , sum);
               }
            }
             2nd How to write test case for private using calling private method by public method
             --------------------------------------------------------------------------------------
             -> create a public method in Library class 
             -> through public method retrun private the method

             -> public class Library{

                private int sumOfTwoNumbers(Integer a , Integer b){
                return a+b;
                }

                public int sumOfNumbers(int a , int b){
                return sumOfTwoNumbers(a,b);
                 }
                }
             -> Testing same as public method

              3rd case using Reflection to write the test cases for private methods
              ---------------------------------------------------------------------
              Rule 1 -> 1st get the method through reflection
              Rule 2 ->  2nd change the access modifier -> using setAccessible().
              Rule 3 -> Invoke the object with the parameters
              Rule 4 -> Assert the value to check the it correct or not 
                public class LibraryTest{
                     @Test
                     public void testSumOfTwoNumbers(){
                         Method method = Library.class.getDeclareMethod("sumOfTwoNumbers",Integer.class , Integer.class);
                         method.setAccessibile(true);
                         Library library = new Library();
                         int sum =  method.invoke(library , 10,30);
                         assertsEqual(40 , sum);

                     }
                  }    
                
   56 ) How to perform Unit testing for the REst API in the Spring 
   ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
   -> To performt the Junit testing for REST api classes for that 

  57) WHat is difference between Monolithic Applications and Microservices Architecture based Applications
  +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
      Aspect             |  Monolithic Application                |   Microservices Application
      ===================================================================================================
      Architecture       |  Single unit                           |   Multiple independent services
      ---------------------------------------------------------------------------------------------------
      Scalability        |  Limited (entire app scales together)  |   High (scale services independently)
      ------------------------------------------------------------|--------------------------------------
      Deployment         |  Single deployment for all features    |   Independent deployment of services
      ------------------------------------------------------------|--------------------------------------
      Single point failure| Entire app may fail                   |   Localized failures (fault isolation)
      --------------------------------------------------------------------------------------------------
      Technology Stack   |  Uniform                               |   Diverse (polyglot architecture)
      --------------------------------------------------------------------------------------------------
      Database           |  Centralized                           |   Decentralized (per service)
      --------------------------------------------------------------------------------------------------
      Development Speed  |  Slower as the app grows               |   Faster with independent teams
      --------------------------------------------------------------------------------------------------
      Maintenance        |  Challenging for large apps            |   Easier for modularized components
      --------------------------------------------------------------------------------------------------
      Communication      |  Internal                              |   External (via APIs, queues, etc.)
      --------------------------------------------------------------------------------------------------

      When to Choose Which?
      --------------------
      Monolithic Applications:
      -----------------------
      Best for small to medium-sized applications.
      Suitable when the application doesn't require frequent scaling.
      Easier for small teams with limited resources.

      Microservices Applications:
      --------------------------
      Ideal for large, complex, and evolving systems.
      Necessary when different parts of the system have varied scaling and technology needs.
      Suitable for teams experienced in distributed systems.


  58)Write a class which show all OOPS principles ??
  +++++++++++++++++++++++++++++++++++++++++++++++
   
         interface User {                          // Abstraction
             User getUserById(Integer id);
         }

         public class UserImpl implements User {  // Inheritence
             private String userName;             // Encapsulation

            //setter                              
            //getter

             @Override
             public User getUserById(Integer id) { // Polymorphism
                 // Implementation logic 
             }

             public static void main(String[] args) {
                 UserImpl userImpl = new UserImpl();
                 userImpl.setUserName("JaneDoe");
                 System.out.println("User Name: " + userImpl.getUserName());
                 User fetchedUser = userImpl.getUserById(2);
                 System.out.println("Fetched User Name: " + ((UserImpl) fetchedUser).getUserName());
             }
         }
